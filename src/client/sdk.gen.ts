// This file is auto-generated by @hey-api/openapi-ts

import { type Options as ClientOptions, type TDataShape, type Client, urlSearchParamsBodySerializer } from '@hey-api/client-fetch';
import type { ApiUsersStatusData, ApiUsersStatusResponse, PlayerData, PlayerResponse, PlayerTopNbPerfTypeData, PlayerTopNbPerfTypeResponse, ApiUserData, ApiUserResponse, ApiUserRatingHistoryData, ApiUserRatingHistoryResponse, ApiUserPerfData, ApiUserPerfResponse, ApiUserActivityData, ApiUserActivityResponse, ApiPuzzleDailyData, ApiPuzzleDailyResponse, ApiPuzzleIdData, ApiPuzzleIdResponse, ApiPuzzleNextData, ApiPuzzleNextResponse, ApiPuzzleActivityData, ApiPuzzleActivityResponse, ApiPuzzleReplayData, ApiPuzzleReplayResponse, ApiPuzzleReplayError, ApiPuzzleDashboardData, ApiPuzzleDashboardResponse, ApiStormDashboardData, ApiStormDashboardResponse, RacerPostData, RacerPostResponse, ApiUsersData, ApiUsersResponse, AccountMeData, AccountMeResponse, AccountEmailData, AccountEmailResponse, AccountData, AccountResponse, AccountKidData, AccountKidResponse, AccountKidPostData, AccountKidPostResponse, TimelineData, TimelineResponse, GamePgnData, GamePgnResponse, ApiUserCurrentGameData, ApiUserCurrentGameResponse, ApiGamesUserData, ApiGamesUserResponse, GamesExportIdsData, GamesExportIdsResponse, GamesByUsersData, GamesByUsersResponse, GamesByIdsData, GamesByIdsResponse, GamesByIdsAddData, GamesByIdsAddResponse, ApiAccountPlayingData, ApiAccountPlayingResponse, StreamGameData, StreamGameResponse, GameImportData, GameImportResponse, ApiImportedGamesUserData, ApiImportedGamesUserResponse, ApiExportBookmarksData, ApiExportBookmarksResponse, TvChannelsData, TvChannelsResponse, TvFeedData, TvFeedResponse, TvChannelFeedData, TvChannelFeedResponse, TvChannelGamesData, TvChannelGamesResponse, ApiTournamentData, ApiTournamentResponse, ApiTournamentPostData, ApiTournamentPostResponse, ApiTournamentPostError, TournamentData, TournamentResponse, ApiTournamentUpdateData, ApiTournamentUpdateResponse, ApiTournamentUpdateError, ApiTournamentJoinData, ApiTournamentJoinResponse, ApiTournamentJoinError, ApiTournamentWithdrawData, ApiTournamentWithdrawResponse, ApiTournamentWithdrawError, ApiTournamentTerminateData, ApiTournamentTerminateResponse, ApiTournamentTerminateError, ApiTournamentTeamBattlePostData, ApiTournamentTeamBattlePostResponse, ApiTournamentTeamBattlePostError, GamesByTournamentData, GamesByTournamentResponse, ResultsByTournamentData, ResultsByTournamentResponse, TeamsByTournamentData, TeamsByTournamentResponse, ApiUserNameTournamentCreatedData, ApiUserNameTournamentCreatedResponse, ApiUserNameTournamentPlayedData, ApiUserNameTournamentPlayedResponse, ApiSwissNewData, ApiSwissNewResponse, ApiSwissNewError, SwissData, SwissResponse, ApiSwissUpdateData, ApiSwissUpdateResponse, ApiSwissUpdateError, ApiSwissScheduleNextRoundData, ApiSwissScheduleNextRoundResponse, ApiSwissScheduleNextRoundError, ApiSwissJoinData, ApiSwissJoinResponse, ApiSwissJoinError, ApiSwissWithdrawData, ApiSwissWithdrawResponse, ApiSwissTerminateData, ApiSwissTerminateResponse, ApiSwissTerminateError, SwissTrfData, SwissTrfResponse, GamesBySwissData, GamesBySwissResponse, ResultsBySwissData, ResultsBySwissResponse, ApiTeamSwissData, ApiTeamSwissResponse, StudyChapterPgnData, StudyChapterPgnResponse, StudyAllChaptersPgnData, StudyAllChaptersPgnResponse, StudyAllChaptersHeadData, StudyAllChaptersHeadResponse, ApiStudyImportPgnData, ApiStudyImportPgnResponse, ApiStudyImportPgnError, StudyExportAllPgnData, StudyExportAllPgnResponse, StudyListMetadataData, StudyListMetadataResponse, ApiStudyStudyIdChapterIdDeleteData, ApiStudyStudyIdChapterIdDeleteResponse, BroadcastsOfficialData, BroadcastsOfficialResponse, BroadcastsTopData, BroadcastsTopResponse, BroadcastsByUserData, BroadcastsByUserResponse, BroadcastTourCreateData, BroadcastTourCreateResponse, BroadcastTourCreateError, BroadcastTourGetData, BroadcastTourGetResponse, BroadcastPlayersGetData, BroadcastPlayersGetResponse, BroadcastTourUpdateData, BroadcastTourUpdateResponse, BroadcastTourUpdateError, BroadcastRoundCreateData, BroadcastRoundCreateResponse, BroadcastRoundCreateError, BroadcastRoundGetData, BroadcastRoundGetResponse, BroadcastRoundUpdateData, BroadcastRoundUpdateResponse, BroadcastRoundUpdateError, BroadcastRoundResetData, BroadcastRoundResetResponse, BroadcastPushData, BroadcastPushResponse, BroadcastPushError, BroadcastStreamRoundPgnData, BroadcastStreamRoundPgnResponse, BroadcastRoundPgnData, BroadcastRoundPgnResponse, BroadcastAllRoundsPgnData, BroadcastAllRoundsPgnResponse, BroadcastMyRoundsGetData, BroadcastMyRoundsGetResponse, FidePlayerGetData, FidePlayerGetResponse, FidePlayerSearchData, FidePlayerSearchResponse, ApiSimulData, ApiSimulResponse, TeamShowData, TeamShowResponse, TeamAllData, TeamAllResponse, TeamOfUsernameData, TeamOfUsernameResponse, TeamSearchData, TeamSearchResponse, TeamIdUsersData, TeamIdUsersResponse, ApiTeamArenaData, ApiTeamArenaResponse, TeamIdJoinData, TeamIdJoinResponse, TeamIdQuitData, TeamIdQuitResponse, TeamRequestsData, TeamRequestsResponse, TeamRequestAcceptData, TeamRequestAcceptResponse, TeamRequestDeclineData, TeamRequestDeclineResponse, TeamIdKickUserIdData, TeamIdKickUserIdResponse, TeamIdPmAllData, TeamIdPmAllResponse, TeamIdPmAllError, StreamerLiveData, StreamerLiveResponse, ApiCrosstableData, ApiCrosstableResponse, ApiPlayerAutocompleteData, ApiPlayerAutocompleteResponse, ReadNoteData, ReadNoteResponse, WriteNoteData, WriteNoteResponse, ApiUserFollowingData, ApiUserFollowingResponse, FollowUserData, FollowUserResponse, UnfollowUserData, UnfollowUserResponse, BlockUserData, BlockUserResponse, UnblockUserData, UnblockUserResponse, ApiStreamEventData, ApiStreamEventResponse, ApiBoardSeekData, ApiBoardSeekResponse, ApiBoardSeekError, BoardGameStreamData, BoardGameStreamResponse, BoardGameStreamError, BoardGameMoveData, BoardGameMoveResponse, BoardGameMoveError, BoardGameChatGetData, BoardGameChatGetResponse, BoardGameChatPostData, BoardGameChatPostResponse, BoardGameChatPostError, BoardGameAbortData, BoardGameAbortResponse, BoardGameAbortError, BoardGameResignData, BoardGameResignResponse, BoardGameResignError, BoardGameDrawData, BoardGameDrawResponse, BoardGameDrawError, BoardGameTakebackData, BoardGameTakebackResponse, BoardGameTakebackError, BoardGameClaimVictoryData, BoardGameClaimVictoryResponse, BoardGameClaimVictoryError, BoardGameBerserkData, BoardGameBerserkResponse, BoardGameBerserkError, ApiBotOnlineData, ApiBotOnlineResponse, BotAccountUpgradeData, BotAccountUpgradeResponse, BotAccountUpgradeError, BotGameStreamData, BotGameStreamResponse, BotGameStreamError, BotGameMoveData, BotGameMoveResponse, BotGameMoveError, BotGameChatGetData, BotGameChatGetResponse, BotGameChatData, BotGameChatResponse, BotGameChatError, BotGameAbortData, BotGameAbortResponse, BotGameAbortError, BotGameResignData, BotGameResignResponse, BotGameResignError, BotGameDrawData, BotGameDrawResponse, BotGameDrawError, BotGameTakebackData, BotGameTakebackResponse, BotGameTakebackError, BotGameClaimVictoryData, BotGameClaimVictoryResponse, BotGameClaimVictoryError, ChallengeListData, ChallengeListResponse, ChallengeCreateData, ChallengeCreateResponse, ChallengeCreateError, ChallengeShowData, ChallengeShowResponse, ChallengeAcceptData, ChallengeAcceptResponse, ChallengeAcceptError, ChallengeDeclineData, ChallengeDeclineResponse, ChallengeDeclineError, ChallengeCancelData, ChallengeCancelResponse, ChallengeCancelError, ChallengeAiData, ChallengeAiResponse, ChallengeAiError, ChallengeOpenData, ChallengeOpenResponse, ChallengeOpenError, ChallengeStartClocksData, ChallengeStartClocksResponse, BulkPairingListData, BulkPairingListResponse, BulkPairingCreateData, BulkPairingCreateResponse, BulkPairingCreateError, BulkPairingStartClocksData, BulkPairingStartClocksResponse, BulkPairingStartClocksError, BulkPairingDeleteData, BulkPairingDeleteResponse, BulkPairingDeleteError, BulkPairingGetData, BulkPairingGetResponse, BulkPairingGetError, BulkPairingIdGamesGetData, BulkPairingIdGamesGetResponse, RoundAddTimeData, RoundAddTimeResponse, AdminChallengeTokensData, AdminChallengeTokensResponse, AdminChallengeTokensError, InboxUsernameData, InboxUsernameResponse, InboxUsernameError, ApiCloudEvalData, ApiCloudEvalResponse, ApiCloudEvalError, ApiExternalEngineListData, ApiExternalEngineListResponse, ApiExternalEngineCreateData, ApiExternalEngineCreateResponse, ApiExternalEngineDeleteData, ApiExternalEngineDeleteResponse, ApiExternalEngineGetData, ApiExternalEngineGetResponse, ApiExternalEnginePutData, ApiExternalEnginePutResponse, ApiExternalEngineAnalyseData, ApiExternalEngineAnalyseResponse, ApiExternalEngineAcquireData, ApiExternalEngineAcquireResponse, ApiExternalEngineSubmitData, OauthData, ApiTokenDeleteData, ApiTokenDeleteResponse, ApiTokenData, ApiTokenResponse, ApiTokenError, TokenTestData, TokenTestResponse, OpeningExplorerMasterData, OpeningExplorerMasterResponse, OpeningExplorerLichessData, OpeningExplorerLichessResponse, OpeningExplorerPlayerData, OpeningExplorerPlayerResponse, OpeningExplorerMasterGameData, OpeningExplorerMasterGameResponse, TablebaseStandardData, TablebaseStandardResponse, TablebaseAtomicData, TablebaseAtomicResponse, AntichessAtomicData, AntichessAtomicResponse } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Get real-time users status
 * Read the `online`, `playing` and `streaming` flags of several users.
 * This API is very fast and cheap on lichess side.
 * So you can call it quite often (like once every 5 seconds).
 * Use it to track players and know when they're connected on lichess and playing games.
 *
 */
export const apiUsersStatus = <ThrowOnError extends boolean = false>(options: Options<ApiUsersStatusData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiUsersStatusResponse, unknown, ThrowOnError>({
        url: '/api/users/status',
        ...options
    });
};

/**
 * Get all top 10
 * Get the top 10 players for each speed and variant.
 * See <https://lichess.org/player>.
 *
 */
export const player = <ThrowOnError extends boolean = false>(options?: Options<PlayerData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<PlayerResponse, unknown, ThrowOnError>({
        url: '/api/player',
        ...options
    });
};

/**
 * Get one leaderboard
 * Get the leaderboard for a single speed or variant (a.k.a. `perfType`).
 * There is no leaderboard for correspondence or puzzles.
 * See <https://lichess.org/player/top/200/bullet>.
 *
 */
export const playerTopNbPerfType = <ThrowOnError extends boolean = false>(options: Options<PlayerTopNbPerfTypeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<PlayerTopNbPerfTypeResponse, unknown, ThrowOnError>({
        url: '/api/player/top/{nb}/{perfType}',
        ...options
    });
};

/**
 * Get user public data
 * Read public data of a user.
 *
 */
export const apiUser = <ThrowOnError extends boolean = false>(options: Options<ApiUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiUserResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/user/{username}',
        ...options
    });
};

/**
 * Get rating history of a user
 * Read rating history of a user, for all perf types.
 * There is at most one entry per day.
 * Format of an entry is `[year, month, day, rating]`.
 * `month` starts at zero (January).
 *
 */
export const apiUserRatingHistory = <ThrowOnError extends boolean = false>(options: Options<ApiUserRatingHistoryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiUserRatingHistoryResponse, unknown, ThrowOnError>({
        url: '/api/user/{username}/rating-history',
        ...options
    });
};

/**
 * Get performance statistics of a user
 * Read performance statistics of a user, for a single performance.
 * Similar to the [performance pages on the website](https://lichess.org/@/thibault/perf/bullet).
 *
 */
export const apiUserPerf = <ThrowOnError extends boolean = false>(options: Options<ApiUserPerfData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiUserPerfResponse, unknown, ThrowOnError>({
        url: '/api/user/{username}/perf/{perf}',
        ...options
    });
};

/**
 * Get user activity
 * Read data to generate the activity feed of a user.
 *
 */
export const apiUserActivity = <ThrowOnError extends boolean = false>(options: Options<ApiUserActivityData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiUserActivityResponse, unknown, ThrowOnError>({
        url: '/api/user/{username}/activity',
        ...options
    });
};

/**
 * Get the daily puzzle
 * Get the daily Lichess puzzle in JSON format.
 * Alternatively, you can [post it in your slack workspace](https://lichess.org/daily-puzzle-slack).
 *
 */
export const apiPuzzleDaily = <ThrowOnError extends boolean = false>(options?: Options<ApiPuzzleDailyData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ApiPuzzleDailyResponse, unknown, ThrowOnError>({
        url: '/api/puzzle/daily',
        ...options
    });
};

/**
 * Get a puzzle by its ID
 * Get a single Lichess puzzle in JSON format.
 */
export const apiPuzzleId = <ThrowOnError extends boolean = false>(options: Options<ApiPuzzleIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiPuzzleIdResponse, unknown, ThrowOnError>({
        url: '/api/puzzle/{id}',
        ...options
    });
};

/**
 * Get a new puzzle
 * Get a random Lichess puzzle in JSON format.
 *
 * If authenticated, only returns puzzles that the user has never seen before.
 *
 * **DO NOT** use this endpoint to enumerate puzzles for mass download. Instead, download the [full public puzzle database](https://database.lichess.org/#puzzles).
 *
 */
export const apiPuzzleNext = <ThrowOnError extends boolean = false>(options?: Options<ApiPuzzleNextData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ApiPuzzleNextResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/puzzle/next',
        ...options
    });
};

/**
 * Get your puzzle activity
 * Download your puzzle activity in [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Puzzle activity is sorted by reverse chronological order (most recent first)
 * We recommend streaming the response, for it can be very long.
 *
 */
export const apiPuzzleActivity = <ThrowOnError extends boolean = false>(options?: Options<ApiPuzzleActivityData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ApiPuzzleActivityResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/puzzle/activity',
        ...options
    });
};

/**
 * Get puzzles to replay
 * Gets the puzzle IDs of remaining puzzles to re-attempt in JSON format.
 */
export const apiPuzzleReplay = <ThrowOnError extends boolean = false>(options: Options<ApiPuzzleReplayData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiPuzzleReplayResponse, ApiPuzzleReplayError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/puzzle/replay/{days}/{theme}',
        ...options
    });
};

/**
 * Get your puzzle dashboard
 * Download your [puzzle dashboard](https://lichess.org/training/dashboard/30/dashboard) as JSON.
 * Also includes all puzzle themes played, with aggregated results.
 * Allows re-creating the [improvement/strengths](https://lichess.org/training/dashboard/30/improvementAreas) interfaces.
 *
 */
export const apiPuzzleDashboard = <ThrowOnError extends boolean = false>(options: Options<ApiPuzzleDashboardData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiPuzzleDashboardResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/puzzle/dashboard/{days}',
        ...options
    });
};

/**
 * Get the storm dashboard of a player
 * Download the [storm dashboard](https://lichess.org/storm/dashboard/mrbasso) of any player as JSON.
 * Contains the aggregated highscores, and the history of storm runs aggregated by days.
 * Use `?days=0` if you only care about the highscores.
 *
 */
export const apiStormDashboard = <ThrowOnError extends boolean = false>(options: Options<ApiStormDashboardData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiStormDashboardResponse, unknown, ThrowOnError>({
        url: '/api/storm/dashboard/{username}',
        ...options
    });
};

/**
 * Create and join a puzzle race
 * Create a new private [puzzle race](https://lichess.org/racer).
 * The Lichess user who creates the race must join the race page,
 * and manually start the race when enough players have joined.
 * - <https://lichess.org/racer>
 *
 */
export const racerPost = <ThrowOnError extends boolean = false>(options?: Options<RacerPostData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<RacerPostResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/racer',
        ...options
    });
};

/**
 * Get users by ID
 * Get up to 300 users by their IDs. Users are returned in the same order as the IDs.
 * The method is `POST` to allow a longer list of IDs to be sent in the request body.
 * Please do not try to download all the Lichess users with this endpoint, or any other endpoint.
 * An API is not a way to fully export a website. We do not provide a full download of the Lichess users.
 * This endpoint is limited to 8,000 users every 10 minutes, and 120,000 every day.
 *
 */
export const apiUsers = <ThrowOnError extends boolean = false>(options: Options<ApiUsersData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiUsersResponse, unknown, ThrowOnError>({
        bodySerializer: null,
        url: '/api/users',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};

/**
 * Get my profile
 * Public information about the logged in user.
 *
 */
export const accountMe = <ThrowOnError extends boolean = false>(options?: Options<AccountMeData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<AccountMeResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/account',
        ...options
    });
};

/**
 * Get my email address
 * Read the email address of the logged in user.
 *
 */
export const accountEmail = <ThrowOnError extends boolean = false>(options?: Options<AccountEmailData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<AccountEmailResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/account/email',
        ...options
    });
};

/**
 * Get my preferences
 * Read the preferences of the logged in user.
 * - <https://lichess.org/account/preferences/game-display>
 * - <https://github.com/ornicar/lila/blob/master/modules/pref/src/main/Pref.scala>
 *
 */
export const account = <ThrowOnError extends boolean = false>(options?: Options<AccountData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<AccountResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/account/preferences',
        ...options
    });
};

/**
 * Get my kid mode status
 * Read the kid mode status of the logged in user.
 * - <https://lichess.org/account/kid>
 *
 */
export const accountKid = <ThrowOnError extends boolean = false>(options?: Options<AccountKidData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<AccountKidResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/account/kid',
        ...options
    });
};

/**
 * Set my kid mode status
 * Set the kid mode status of the logged in user.
 * - <https://lichess.org/account/kid>
 *
 */
export const accountKidPost = <ThrowOnError extends boolean = false>(options: Options<AccountKidPostData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<AccountKidPostResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/account/kid',
        ...options
    });
};

/**
 * Get my timeline
 * Get the timeline events of the logged in user.
 *
 */
export const timeline = <ThrowOnError extends boolean = false>(options?: Options<TimelineData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<TimelineResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/timeline',
        ...options
    });
};

/**
 * Export one game
 * Download one game in either PGN or JSON format.
 * Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
 *
 */
export const gamePgn = <ThrowOnError extends boolean = false>(options: Options<GamePgnData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GamePgnResponse, unknown, ThrowOnError>({
        url: '/game/export/{gameId}',
        ...options
    });
};

/**
 * Export ongoing game of a user
 * Download the ongoing game, or the last game played, of a user.
 * Available in either PGN or JSON format.
 * Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
 *
 */
export const apiUserCurrentGame = <ThrowOnError extends boolean = false>(options: Options<ApiUserCurrentGameData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiUserCurrentGameResponse, unknown, ThrowOnError>({
        url: '/api/user/{username}/current-game',
        ...options
    });
};

/**
 * Export games of a user
 * Download all games of any user in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Games are sorted by reverse chronological order (most recent first).
 * We recommend streaming the response, for it can be very long.
 * <https://lichess.org/@/german11> for instance has more than 500,000 games.
 * The game stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 games per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
 * - Authenticated, downloading your own games: 60 games per second
 *
 */
export const apiGamesUser = <ThrowOnError extends boolean = false>(options: Options<ApiGamesUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiGamesUserResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/games/user/{username}',
        ...options
    });
};

/**
 * Export games by IDs
 * Download games by IDs in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
 * Games are sorted by reverse chronological order (most recent first)
 * The method is `POST` so a longer list of IDs can be sent in the request body.
 * 300 IDs can be submitted.
 * Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
 *
 */
export const gamesExportIds = <ThrowOnError extends boolean = false>(options: Options<GamesExportIdsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<GamesExportIdsResponse, unknown, ThrowOnError>({
        bodySerializer: null,
        url: '/api/games/export/_ids',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};

/**
 * Stream games of users
 * Stream the games played between a list of users, in real time.
 * Only games where **both players** are part of the list are included.
 * The stream emits an event each time a game is started or finished.
 * To also get all current ongoing games at the beginning of the stream, use the `withCurrentGames` flag.
 * Games are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Maximum number of users: 300.
 * The method is `POST` so a longer list of IDs can be sent in the request body.
 *
 */
export const gamesByUsers = <ThrowOnError extends boolean = false>(options: Options<GamesByUsersData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<GamesByUsersResponse, unknown, ThrowOnError>({
        bodySerializer: null,
        url: '/api/stream/games-by-users',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};

/**
 * Stream games by IDs
 * Creates a stream of games from an arbitrary streamId, and a list of game IDs.
 * The stream first outputs the games that already exists, then emits an event each time a game is started or finished.
 * Games are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Maximum number of games: 500 for anonymous requests, or 1000 for [OAuth2 authenticated](#section/Introduction/Authentication) requests.
 * While the stream is open, it is possible to [add new game IDs to watch](#operation/gamesByIdsAdd).
 *
 */
export const gamesByIds = <ThrowOnError extends boolean = false>(options: Options<GamesByIdsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<GamesByIdsResponse, unknown, ThrowOnError>({
        bodySerializer: null,
        url: '/api/stream/games/{streamId}',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};

/**
 * Add game IDs to stream
 * Add new game IDs for [an existing stream](#operation/gamesByIds) to watch.
 * The stream will immediately outputs the games that already exists, then emit an event each time a game is started or finished.
 *
 */
export const gamesByIdsAdd = <ThrowOnError extends boolean = false>(options: Options<GamesByIdsAddData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<GamesByIdsAddResponse, unknown, ThrowOnError>({
        bodySerializer: null,
        url: '/api/stream/games/{streamId}/add',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};

/**
 * Get my ongoing games
 * Get the ongoing games of the current user.
 * Real-time and correspondence games are included.
 * The most urgent games are listed first.
 *
 */
export const apiAccountPlaying = <ThrowOnError extends boolean = false>(options?: Options<ApiAccountPlayingData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ApiAccountPlayingResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/account/playing',
        ...options
    });
};

/**
 * Stream moves of a game
 * Stream positions and moves of any ongoing game, in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * A description of the game is sent as a first message.
 * Then a message is sent each time a move is played.
 * Finally a description of the game is sent when it finishes, and the stream is closed.
 * Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
 * No more than 8 game streams can be opened at the same time from the same IP address.
 *
 */
export const streamGame = <ThrowOnError extends boolean = false>(options: Options<StreamGameData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<StreamGameResponse, unknown, ThrowOnError>({
        url: '/api/stream/game/{id}',
        ...options
    });
};

/**
 * Import one game
 * Import a game from PGN. See <https://lichess.org/paste>.
 * Rate limiting: 200 games per hour for OAuth requests, 100 games per hour for anonymous requests.
 * To broadcast ongoing games, consider [pushing to a broadcast instead](#operation/broadcastPush).
 * To analyse a position or a line, just construct an analysis board URL:
 * [https://lichess.org/analysis/pgn/e4_e5_Nf3_Nc6_Bc4_Bc5_Bxf7+](https://lichess.org/analysis/pgn/e4_e5_Nf3_Nc6_Bc4_Bc5_Bxf7+)
 *
 */
export const gameImport = <ThrowOnError extends boolean = false>(options: Options<GameImportData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<GameImportResponse, unknown, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/import',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Export your imported games
 * Download all games imported by you. Games are exported in PGN format.
 */
export const apiImportedGamesUser = <ThrowOnError extends boolean = false>(options?: Options<ApiImportedGamesUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ApiImportedGamesUserResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/games/export/imports',
        ...options
    });
};

/**
 * Export your bookmarked games
 * Download all games bookmarked by you, in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Games are sorted by reverse chronological order (most recent first).
 * We recommend streaming the response, for it can be very long.
 *
 */
export const apiExportBookmarks = <ThrowOnError extends boolean = false>(options?: Options<ApiExportBookmarksData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ApiExportBookmarksResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/games/export/bookmarks',
        ...options
    });
};

/**
 * Get current TV games
 * Get basic info about the best games being played for each speed and variant,
 * but also computer games and bot games.
 * See [lichess.org/tv](https://lichess.org/tv).
 *
 */
export const tvChannels = <ThrowOnError extends boolean = false>(options?: Options<TvChannelsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<TvChannelsResponse, unknown, ThrowOnError>({
        url: '/api/tv/channels',
        ...options
    });
};

/**
 * Stream current TV game
 * Stream positions and moves of the current [TV game](https://lichess.org/tv) in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Try it with `curl https://lichess.org/api/tv/feed`.
 *
 */
export const tvFeed = <ThrowOnError extends boolean = false>(options?: Options<TvFeedData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<TvFeedResponse, unknown, ThrowOnError>({
        url: '/api/tv/feed',
        ...options
    });
};

/**
 * Stream current TV game of a TV channel
 * Stream positions and moves of a current [TV channel's game](https://lichess.org/tv/rapid) in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Try it with `curl https://lichess.org/api/tv/rapid/feed`.
 *
 */
export const tvChannelFeed = <ThrowOnError extends boolean = false>(options: Options<TvChannelFeedData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<TvChannelFeedResponse, unknown, ThrowOnError>({
        url: '/api/tv/{channel}/feed',
        ...options
    });
};

/**
 * Get best ongoing games of a TV channel
 * Get a list of ongoing games for a given TV channel. Similar to [lichess.org/games](https://lichess.org/games).
 * Available in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
 *
 */
export const tvChannelGames = <ThrowOnError extends boolean = false>(options: Options<TvChannelGamesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<TvChannelGamesResponse, unknown, ThrowOnError>({
        url: '/api/tv/{channel}',
        ...options
    });
};

/**
 * Get current tournaments
 * Get recently active and finished tournaments.
 * This API is used to display the [Lichess tournament schedule](https://lichess.org/tournament).
 *
 */
export const apiTournament = <ThrowOnError extends boolean = false>(options?: Options<ApiTournamentData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ApiTournamentResponse, unknown, ThrowOnError>({
        url: '/api/tournament',
        ...options
    });
};

/**
 * Create a new Arena tournament
 * Create a public or private Arena tournament.
 * This endpoint mirrors the form on <https://lichess.org/tournament/new>.
 * You can create up to 12 public tournaments per day, or 24 private tournaments.
 * A team battle can be created by specifying the `teamBattleByTeam` argument.
 * Additional restrictions:
 * - clockTime + clockIncrement > 0
 * - 15s and 0+1 variant tournaments cannot be rated
 * - Clock time in comparison to tournament length must be reasonable: 3 <= (minutes * 60) / (96 * clockTime + 48 * clockIncrement + 15) <= 150
 *
 */
export const apiTournamentPost = <ThrowOnError extends boolean = false>(options: Options<ApiTournamentPostData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiTournamentPostResponse, ApiTournamentPostError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/tournament',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Get info about an Arena tournament
 * Get detailed info about recently finished, current, or upcoming tournament's duels, player standings, and other info.
 *
 */
export const tournament = <ThrowOnError extends boolean = false>(options: Options<TournamentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<TournamentResponse, unknown, ThrowOnError>({
        url: '/api/tournament/{id}',
        ...options
    });
};

/**
 * Update an Arena tournament
 * Update an Arena tournament.
 * Be mindful not to make important changes to ongoing tournaments.
 * Can be used to update a team battle.
 * Additional restrictions:
 * - clockTime + clockIncrement > 0
 * - 15s and 0+1 variant tournaments cannot be rated
 * - Clock time in comparison to tournament length must be reasonable: 3 <= (minutes * 60) / (96 * clockTime + 48 * clockIncrement + 15) <= 150
 *
 */
export const apiTournamentUpdate = <ThrowOnError extends boolean = false>(options: Options<ApiTournamentUpdateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiTournamentUpdateResponse, ApiTournamentUpdateError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/tournament/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Join an Arena tournament
 * Join an Arena tournament, possibly with a password and/or a team.
 * Also unpauses if you had previously [paused](#operation/apiTournamentWithdraw) the tournament.
 *
 */
export const apiTournamentJoin = <ThrowOnError extends boolean = false>(options: Options<ApiTournamentJoinData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiTournamentJoinResponse, ApiTournamentJoinError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/tournament/{id}/join',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Pause or leave an Arena tournament
 * Leave a future Arena tournament, or take a break on an ongoing Arena tournament.
 * It's possible to join again later. Points and streaks are preserved.
 *
 */
export const apiTournamentWithdraw = <ThrowOnError extends boolean = false>(options: Options<ApiTournamentWithdrawData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiTournamentWithdrawResponse, ApiTournamentWithdrawError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/tournament/{id}/withdraw',
        ...options
    });
};

/**
 * Terminate an Arena tournament
 * Terminate an Arena tournament
 *
 */
export const apiTournamentTerminate = <ThrowOnError extends boolean = false>(options: Options<ApiTournamentTerminateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiTournamentTerminateResponse, ApiTournamentTerminateError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/tournament/{id}/terminate',
        ...options
    });
};

/**
 * Update a team battle
 * Set the teams and number of leaders of a team battle.
 * To update the other attributes of a team battle, use the [tournament update endpoint](#operation/apiTournamentUpdate).
 *
 */
export const apiTournamentTeamBattlePost = <ThrowOnError extends boolean = false>(options: Options<ApiTournamentTeamBattlePostData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiTournamentTeamBattlePostResponse, ApiTournamentTeamBattlePostError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/tournament/team-battle/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Export games of an Arena tournament
 * Download games of a tournament in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Games are sorted by reverse chronological order (most recent first).
 * The game stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 games per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
 *
 */
export const gamesByTournament = <ThrowOnError extends boolean = false>(options: Options<GamesByTournamentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GamesByTournamentResponse, unknown, ThrowOnError>({
        url: '/api/tournament/{id}/games',
        ...options
    });
};

/**
 * Get results of an Arena tournament
 * Players of an Arena tournament, with their score and performance, sorted by rank (best first).
 * **Players are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON)**, i.e. one JSON object per line.
 * If called on an ongoing tournament, results can be inconsistent
 * due to ranking changes while the players are being streamed.
 * Use on finished tournaments for guaranteed consistency.
 *
 */
export const resultsByTournament = <ThrowOnError extends boolean = false>(options: Options<ResultsByTournamentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ResultsByTournamentResponse, unknown, ThrowOnError>({
        url: '/api/tournament/{id}/results',
        ...options
    });
};

/**
 * Get team standing of a team battle
 * Teams of a team battle tournament, with top players, sorted by rank (best first).
 *
 */
export const teamsByTournament = <ThrowOnError extends boolean = false>(options: Options<TeamsByTournamentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<TeamsByTournamentResponse, unknown, ThrowOnError>({
        url: '/api/tournament/{id}/teams',
        ...options
    });
};

/**
 * Get tournaments created by a user
 * Get all tournaments created by a given user.
 * Tournaments are sorted by reverse chronological order of start date (last starting first).
 * Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * The stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 tournaments per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 tournaments per second
 * - Authenticated, downloading your own tournaments: 50 games per second
 *
 */
export const apiUserNameTournamentCreated = <ThrowOnError extends boolean = false>(options: Options<ApiUserNameTournamentCreatedData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiUserNameTournamentCreatedResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/user/{username}/tournament/created',
        ...options
    });
};

/**
 * Get tournaments played by a user
 * Get all tournaments played by a given user.
 * Tournaments are sorted by reverse chronological order of start date (last played first).
 * Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * The stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 tournaments per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 tournaments per second
 * - Authenticated, downloading your own tournaments: 50 games per second
 *
 */
export const apiUserNameTournamentPlayed = <ThrowOnError extends boolean = false>(options: Options<ApiUserNameTournamentPlayedData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiUserNameTournamentPlayedResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/user/{username}/tournament/played',
        ...options
    });
};

/**
 * Create a new Swiss tournament
 * Create a Swiss tournament for your team.
 * This endpoint mirrors the Swiss tournament form from your team pagee.
 * You can create up to 12 tournaments per day.
 * Additional restrictions:
 * - clock.limit + clock.increment > 0
 * - 15s and 0+1 variant tournaments cannot be rated
 *
 */
export const apiSwissNew = <ThrowOnError extends boolean = false>(options: Options<ApiSwissNewData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiSwissNewResponse, ApiSwissNewError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/swiss/new/{teamId}',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Get info about a Swiss tournament
 * Get detailed info about a Swiss tournament.
 *
 */
export const swiss = <ThrowOnError extends boolean = false>(options: Options<SwissData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<SwissResponse, unknown, ThrowOnError>({
        url: '/api/swiss/{id}',
        ...options
    });
};

/**
 * Update a Swiss tournament
 * Update a Swiss tournament.
 * Be mindful not to make important changes to ongoing tournaments.
 * Additional restrictions:
 * - clock.limit + clock.increment > 0
 * - 15s and 0+1 variant tournaments cannot be rated
 *
 */
export const apiSwissUpdate = <ThrowOnError extends boolean = false>(options: Options<ApiSwissUpdateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiSwissUpdateResponse, ApiSwissUpdateError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/swiss/{id}/edit',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Manually schedule the next round
 * Manually schedule the next round date and time of a Swiss tournament.
 * This sets the `roundInterval` field to `99999999`, i.e. manual scheduling.
 * All further rounds will need to be manually scheduled, unless the `roundInterval` field is changed back to automatic scheduling.
 *
 */
export const apiSwissScheduleNextRound = <ThrowOnError extends boolean = false>(options: Options<ApiSwissScheduleNextRoundData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiSwissScheduleNextRoundResponse, ApiSwissScheduleNextRoundError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/swiss/{id}/schedule-next-round',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Join a Swiss tournament
 * Join a Swiss tournament, possibly with a password.
 *
 */
export const apiSwissJoin = <ThrowOnError extends boolean = false>(options: Options<ApiSwissJoinData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiSwissJoinResponse, ApiSwissJoinError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/swiss/{id}/join',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Pause or leave a swiss tournament
 * Leave a future Swiss tournament, or take a break on an ongoing Swiss tournament.
 * It's possible to join again later. Points are preserved.
 *
 */
export const apiSwissWithdraw = <ThrowOnError extends boolean = false>(options: Options<ApiSwissWithdrawData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiSwissWithdrawResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/swiss/{id}/withdraw',
        ...options
    });
};

/**
 * Terminate a Swiss tournament
 * Terminate a Swiss tournament
 *
 */
export const apiSwissTerminate = <ThrowOnError extends boolean = false>(options: Options<ApiSwissTerminateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiSwissTerminateResponse, ApiSwissTerminateError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/swiss/{id}/terminate',
        ...options
    });
};

/**
 * Export TRF of a Swiss tournament
 * Download a tournament in the Tournament Report File format, the FIDE standard.
 * Documentation: <https://www.fide.com/FIDE/handbook/C04Annex2_TRF16.pdf>
 * Example: <https://lichess.org/swiss/j8rtJ5GL.trf>
 *
 */
export const swissTrf = <ThrowOnError extends boolean = false>(options: Options<SwissTrfData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<SwissTrfResponse, unknown, ThrowOnError>({
        url: '/swiss/{id}.trf',
        ...options
    });
};

/**
 * Export games of a Swiss tournament
 * Download games of a swiss tournament in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
 * Games are sorted by chronological order.
 * The game stream is throttled, depending on who is making the request:
 * - Anonymous request: 20 games per second
 * - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
 *
 */
export const gamesBySwiss = <ThrowOnError extends boolean = false>(options: Options<GamesBySwissData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GamesBySwissResponse, unknown, ThrowOnError>({
        url: '/api/swiss/{id}/games',
        ...options
    });
};

/**
 * Get results of a swiss tournament
 * Players of a swiss tournament, with their score and performance, sorted by rank (best first).
 * Players are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * If called on an ongoing tournament, results can be inconsistent
 * due to ranking changes while the players are being streamed.
 * Use on finished tournaments for guaranteed consistency.
 *
 */
export const resultsBySwiss = <ThrowOnError extends boolean = false>(options: Options<ResultsBySwissData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ResultsBySwissResponse, unknown, ThrowOnError>({
        url: '/api/swiss/{id}/results',
        ...options
    });
};

/**
 * Get team swiss tournaments
 * Get all swiss tournaments of a team.
 * Tournaments are sorted by reverse chronological order of start date (last starting first).
 * Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */
export const apiTeamSwiss = <ThrowOnError extends boolean = false>(options: Options<ApiTeamSwissData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiTeamSwissResponse, unknown, ThrowOnError>({
        url: '/api/team/{teamId}/swiss',
        ...options
    });
};

/**
 * Export one study chapter
 * Download one study chapter in PGN format.
 *
 */
export const studyChapterPgn = <ThrowOnError extends boolean = false>(options: Options<StudyChapterPgnData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<StudyChapterPgnResponse, unknown, ThrowOnError>({
        url: '/api/study/{studyId}/{chapterId}.pgn',
        ...options
    });
};

/**
 * Export all chapters
 * Download all chapters of a study in PGN format.
 *
 */
export const studyAllChaptersPgn = <ThrowOnError extends boolean = false>(options: Options<StudyAllChaptersPgnData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<StudyAllChaptersPgnResponse, unknown, ThrowOnError>({
        url: '/api/study/{studyId}.pgn',
        ...options
    });
};

/**
 * Study metadata
 * Only get the study headers, including `Last-Modified`.
 *
 */
export const studyAllChaptersHead = <ThrowOnError extends boolean = false>(options: Options<StudyAllChaptersHeadData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).head<StudyAllChaptersHeadResponse, unknown, ThrowOnError>({
        url: '/api/study/{studyId}.pgn',
        ...options
    });
};

/**
 * Import PGN into a study
 * Imports arbitrary PGN into an existing [study](https://lichess.org/study). Creates a new chapter in the study.
 * If the PGN contains multiple games (separated by 2 or more newlines)
 * then multiple chapters will be created within the study.
 * Note that a study can contain at most 64 chapters.
 *
 */
export const apiStudyImportPgn = <ThrowOnError extends boolean = false>(options: Options<ApiStudyImportPgnData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiStudyImportPgnResponse, ApiStudyImportPgnError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/study/{studyId}/import-pgn',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Export all studies of a user
 * Download all chapters of all studies of a user in PGN format.
 * If authenticated, then all public, unlisted, and private studies are included.
 * If not, only public (non-unlisted) studies are included.
 *
 */
export const studyExportAllPgn = <ThrowOnError extends boolean = false>(options: Options<StudyExportAllPgnData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<StudyExportAllPgnResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/study/by/{username}/export.pgn',
        ...options
    });
};

/**
 * List studies of a user
 * Get metadata (name and dates) of all studies of a user.
 * If authenticated, then all public, unlisted, and private studies are included.
 * If not, only public (non-unlisted) studies are included.
 * Studies are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */
export const studyListMetadata = <ThrowOnError extends boolean = false>(options: Options<StudyListMetadataData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<StudyListMetadataResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/study/by/{username}',
        ...options
    });
};

/**
 * Delete a study chapter
 * Delete a chapter of a study you own. This is definitive.
 * A study must have at least one chapter; so if you delete the last chapter,
 * an empty one will be automatically created to replace it.
 *
 */
export const apiStudyStudyIdChapterIdDelete = <ThrowOnError extends boolean = false>(options: Options<ApiStudyStudyIdChapterIdDeleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<ApiStudyStudyIdChapterIdDeleteResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/study/{studyId}/{chapterId}',
        ...options
    });
};

/**
 * Get official broadcasts
 * Get all incoming, ongoing, and finished official broadcasts.
 * The broadcasts are sorted by start date, most recent first.
 * Broadcasts are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */
export const broadcastsOfficial = <ThrowOnError extends boolean = false>(options?: Options<BroadcastsOfficialData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<BroadcastsOfficialResponse, unknown, ThrowOnError>({
        url: '/api/broadcast',
        ...options
    });
};

/**
 * Get paginated top broadcast previews
 * The same data, in the same order, as can be seen on [https://lichess.org/broadcast](/broadcast).
 *
 */
export const broadcastsTop = <ThrowOnError extends boolean = false>(options?: Options<BroadcastsTopData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<BroadcastsTopResponse, unknown, ThrowOnError>({
        url: '/api/broadcast/top',
        ...options
    });
};

/**
 * Get broadcasts created by a user
 * Get all incoming, ongoing, and finished official broadcasts.
 * The broadcasts are sorted by created date, most recent first.
 *
 */
export const broadcastsByUser = <ThrowOnError extends boolean = false>(options: Options<BroadcastsByUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<BroadcastsByUserResponse, unknown, ThrowOnError>({
        url: '/api/broadcast/by/{username}',
        ...options
    });
};

/**
 * Create a broadcast tournament
 * Create a new broadcast tournament to relay external games.
 * This endpoint accepts the same form data as the [web form](https://lichess.org/broadcast/new).
 *
 */
export const broadcastTourCreate = <ThrowOnError extends boolean = false>(options: Options<BroadcastTourCreateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BroadcastTourCreateResponse, BroadcastTourCreateError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/broadcast/new',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Get a broadcast tournament
 * Get information about a broadcast tournament.
 *
 */
export const broadcastTourGet = <ThrowOnError extends boolean = false>(options: Options<BroadcastTourGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<BroadcastTourGetResponse, unknown, ThrowOnError>({
        url: '/api/broadcast/{broadcastTournamentId}',
        ...options
    });
};

/**
 * Get players of a broadcast
 * Get the list of players of a broadcast tournament, if available.
 *
 */
export const broadcastPlayersGet = <ThrowOnError extends boolean = false>(options: Options<BroadcastPlayersGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<BroadcastPlayersGetResponse, unknown, ThrowOnError>({
        url: '/broadcast/{broadcastTournamentId}/players',
        ...options
    });
};

/**
 * Update your broadcast tournament
 * Update information about a broadcast tournament that you created.
 * This endpoint accepts the same form data as the web form.
 * All fields must be populated with data. Missing fields will override the broadcast with empty data.
 *
 */
export const broadcastTourUpdate = <ThrowOnError extends boolean = false>(options: Options<BroadcastTourUpdateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BroadcastTourUpdateResponse, BroadcastTourUpdateError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/broadcast/{broadcastTournamentId}/edit',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Create a broadcast round
 * Create a new broadcast round to relay external games.
 * This endpoint accepts the same form data as the web form.
 *
 * Choose one between `syncUrl`, `syncUrls`, `syncIds` and `syncUsers`, if it is missing, the broadcast needs to be fed by [pushing PGN to it](#operation/broadcastPush)
 *
 */
export const broadcastRoundCreate = <ThrowOnError extends boolean = false>(options: Options<BroadcastRoundCreateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BroadcastRoundCreateResponse, BroadcastRoundCreateError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/broadcast/{broadcastTournamentId}/new',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Get a broadcast round
 * Get information about a broadcast round.
 *
 */
export const broadcastRoundGet = <ThrowOnError extends boolean = false>(options: Options<BroadcastRoundGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<BroadcastRoundGetResponse, unknown, ThrowOnError>({
        url: '/api/broadcast/{broadcastTournamentSlug}/{broadcastRoundSlug}/{broadcastRoundId}',
        ...options
    });
};

/**
 * Update a broadcast round
 * Update information about a broadcast round.
 * This endpoint accepts the same form data as the web form.
 * All fields must be populated with data. Missing fields will override the broadcast with empty data.
 * For instance, if you omit `startDate`, then any pre-existing start date will be removed.
 *
 */
export const broadcastRoundUpdate = <ThrowOnError extends boolean = false>(options: Options<BroadcastRoundUpdateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BroadcastRoundUpdateResponse, BroadcastRoundUpdateError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/broadcast/round/{broadcastRoundId}/edit',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Reset a broadcast round
 * Remove any games from the broadcast round and reset it to its initial state.
 *
 */
export const broadcastRoundReset = <ThrowOnError extends boolean = false>(options: Options<BroadcastRoundResetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BroadcastRoundResetResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/broadcast/round/{broadcastRoundId}/reset',
        ...options
    });
};

/**
 * Push PGN to a broadcast round
 * Update a broadcast with new PGN.
 * Only for broadcasts without a source URL.
 *
 */
export const broadcastPush = <ThrowOnError extends boolean = false>(options: Options<BroadcastPushData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BroadcastPushResponse, BroadcastPushError, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/broadcast/round/{broadcastRoundId}/push',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};

/**
 * Stream an ongoing broadcast tournament as PGN
 * This streaming endpoint first sends all games of a broadcast tournament in PGN format.
 * Then, it waits for new moves to be played. As soon as it happens, the entire PGN of the game is sent to the stream.
 * The stream will also send PGNs when games are added to the tournament.
 * This is the best way to get updates about an ongoing tournament. Streaming means no polling,
 * and no pollings means no latency, and minimum impact on the server.
 *
 */
export const broadcastStreamRoundPgn = <ThrowOnError extends boolean = false>(options: Options<BroadcastStreamRoundPgnData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<BroadcastStreamRoundPgnResponse, unknown, ThrowOnError>({
        url: '/api/stream/broadcast/round/{broadcastRoundId}.pgn',
        ...options
    });
};

/**
 * Export one round as PGN
 * Download all games of a single round of a broadcast tournament in PGN format.
 * You *could* poll this endpoint to get updates about a tournament, but it would be slow,
 * and very inefficient.
 * Instead, consider [streaming the tournament](#operation/broadcastStreamRoundPgn) to get
 * a new PGN every time a game is updated, in real-time.
 *
 */
export const broadcastRoundPgn = <ThrowOnError extends boolean = false>(options: Options<BroadcastRoundPgnData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<BroadcastRoundPgnResponse, unknown, ThrowOnError>({
        url: '/api/broadcast/round/{broadcastRoundId}.pgn',
        ...options
    });
};

/**
 * Export all rounds as PGN
 * Download all games of all rounds of a broadcast in PGN format.
 * If a `study:read` [OAuth token](#tag/OAuth) is provided,
 * the private rounds where the user is a contributor will be available.
 * You may want to [download only the games of a single round](#operation/broadcastRoundPgn) instead.
 *
 */
export const broadcastAllRoundsPgn = <ThrowOnError extends boolean = false>(options: Options<BroadcastAllRoundsPgnData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<BroadcastAllRoundsPgnResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/broadcast/{broadcastTournamentId}.pgn',
        ...options
    });
};

/**
 * Get your broadcast rounds
 * Stream all broadcast rounds you are a member of.
 * Also includes broadcasts rounds you did not create, but were invited to.
 * Also includes broadcasts rounds where you're a non-writing member. See the `writeable` flag in the response.
 * Rounds are ordered by rank, which is roughly chronological, most recent first, slightly pondered with popularity.
 *
 */
export const broadcastMyRoundsGet = <ThrowOnError extends boolean = false>(options?: Options<BroadcastMyRoundsGetData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<BroadcastMyRoundsGetResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/broadcast/my-rounds',
        ...options
    });
};

/**
 * Get a FIDE player
 * Get information about a FIDE player.
 *
 */
export const fidePlayerGet = <ThrowOnError extends boolean = false>(options: Options<FidePlayerGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<FidePlayerGetResponse, unknown, ThrowOnError>({
        url: '/api/fide/player/{playerId}',
        ...options
    });
};

/**
 * Search FIDE players
 * List of FIDE players search results for a query.
 *
 */
export const fidePlayerSearch = <ThrowOnError extends boolean = false>(options: Options<FidePlayerSearchData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<FidePlayerSearchResponse, unknown, ThrowOnError>({
        url: '/api/fide/player',
        ...options
    });
};

/**
 * Get current simuls
 * Get recently created, started, finished, simuls.
 * Created and finished simul lists are not exhaustives, only those with
 * strong enough host will be listed, the same filter is used to display simuls on https://lichess.org/simul.
 * When [authenticated with OAuth2](#section/Introduction/Authentication), the pending list will be populated with your created, but unstarted simuls.
 *
 */
export const apiSimul = <ThrowOnError extends boolean = false>(options?: Options<ApiSimulData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ApiSimulResponse, unknown, ThrowOnError>({
        url: '/api/simul',
        ...options
    });
};

/**
 * Get a single team
 * Public info about a team. Includes the list of publicly visible leaders.
 */
export const teamShow = <ThrowOnError extends boolean = false>(options: Options<TeamShowData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<TeamShowResponse, unknown, ThrowOnError>({
        url: '/api/team/{teamId}',
        ...options
    });
};

/**
 * Get popular teams
 * Paginator of the most popular teams.
 *
 */
export const teamAll = <ThrowOnError extends boolean = false>(options?: Options<TeamAllData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<TeamAllResponse, unknown, ThrowOnError>({
        url: '/api/team/all',
        ...options
    });
};

/**
 * Teams of a player
 * All the teams a player is a member of.
 *
 */
export const teamOfUsername = <ThrowOnError extends boolean = false>(options: Options<TeamOfUsernameData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<TeamOfUsernameResponse, unknown, ThrowOnError>({
        url: '/api/team/of/{username}',
        ...options
    });
};

/**
 * Search teams
 * Paginator of team search results for a keyword.
 *
 */
export const teamSearch = <ThrowOnError extends boolean = false>(options?: Options<TeamSearchData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<TeamSearchResponse, unknown, ThrowOnError>({
        url: '/api/team/search',
        ...options
    });
};

/**
 * Get members of a team
 * Members are sorted by reverse chronological order of joining the team (most recent first).
 * OAuth is only required if the list of members is private.
 * Up to 5,000 users are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */
export const teamIdUsers = <ThrowOnError extends boolean = false>(options: Options<TeamIdUsersData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<TeamIdUsersResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/team/{teamId}/users',
        ...options
    });
};

/**
 * Get team Arena tournaments
 * Get all Arena tournaments relevant to a team.
 * Tournaments are sorted by reverse chronological order of start date (last starting first).
 * Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */
export const apiTeamArena = <ThrowOnError extends boolean = false>(options: Options<ApiTeamArenaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiTeamArenaResponse, unknown, ThrowOnError>({
        url: '/api/team/{teamId}/arena',
        ...options
    });
};

/**
 * Join a team
 * Join a team.
 * If the team requires a password but the `password` field is incorrect,
 * then the call fails with `403 Forbidden`.
 * Similarly, if the team join policy requires a confirmation but the
 * `message` parameter is not given, then the call fails with
 * `403 Forbidden`.
 *
 */
export const teamIdJoin = <ThrowOnError extends boolean = false>(options: Options<TeamIdJoinData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<TeamIdJoinResponse, unknown, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/team/{teamId}/join',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Leave a team
 * Leave a team.
 * - <https://lichess.org/team>
 *
 */
export const teamIdQuit = <ThrowOnError extends boolean = false>(options: Options<TeamIdQuitData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<TeamIdQuitResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/team/{teamId}/quit',
        ...options
    });
};

/**
 * Get join requests
 * Get pending join requests of your team
 */
export const teamRequests = <ThrowOnError extends boolean = false>(options: Options<TeamRequestsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<TeamRequestsResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/team/{teamId}/requests',
        ...options
    });
};

/**
 * Accept join request
 * Accept someone's request to join your team
 */
export const teamRequestAccept = <ThrowOnError extends boolean = false>(options: Options<TeamRequestAcceptData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<TeamRequestAcceptResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/team/{teamId}/request/{userId}/accept',
        ...options
    });
};

/**
 * Decline join request
 * Decline someone's request to join your team
 */
export const teamRequestDecline = <ThrowOnError extends boolean = false>(options: Options<TeamRequestDeclineData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<TeamRequestDeclineResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/team/{teamId}/request/{userId}/decline',
        ...options
    });
};

/**
 * Kick a user from your team
 * Kick a member out of one of your teams.
 * - <https://lichess.org/team>
 *
 */
export const teamIdKickUserId = <ThrowOnError extends boolean = false>(options: Options<TeamIdKickUserIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<TeamIdKickUserIdResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/team/{teamId}/kick/{userId}',
        ...options
    });
};

/**
 * Message all members
 * Send a private message to all members of a team.
 * You must be a team leader with the "Messages" permission.
 *
 */
export const teamIdPmAll = <ThrowOnError extends boolean = false>(options: Options<TeamIdPmAllData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<TeamIdPmAllResponse, TeamIdPmAllError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/team/{teamId}/pm-all',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Get live streamers
 * Get basic info about currently streaming users.
 * This API is very fast and cheap on lichess side.
 * So you can call it quite often (like once every 5 seconds).
 *
 */
export const streamerLive = <ThrowOnError extends boolean = false>(options?: Options<StreamerLiveData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<StreamerLiveResponse, unknown, ThrowOnError>({
        url: '/api/streamer/live',
        ...options
    });
};

/**
 * Get crosstable
 * Get total number of games, and current score, of any two users.
 * If the `matchup` flag is provided, and the users are currently playing, also gets the current match game number and scores.
 *
 */
export const apiCrosstable = <ThrowOnError extends boolean = false>(options: Options<ApiCrosstableData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiCrosstableResponse, unknown, ThrowOnError>({
        url: '/api/crosstable/{user1}/{user2}',
        ...options
    });
};

/**
 * Autocomplete usernames
 * Provides autocompletion options for an incomplete username.
 *
 */
export const apiPlayerAutocomplete = <ThrowOnError extends boolean = false>(options: Options<ApiPlayerAutocompleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiPlayerAutocompleteResponse, unknown, ThrowOnError>({
        url: '/api/player/autocomplete',
        ...options
    });
};

/**
 * Get notes for a user
 * Get the private notes that you have added for a user.
 *
 */
export const readNote = <ThrowOnError extends boolean = false>(options: Options<ReadNoteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ReadNoteResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/user/{username}/note',
        ...options
    });
};

/**
 * Add a note for a user
 * Add a private note available only to you about this account.
 *
 */
export const writeNote = <ThrowOnError extends boolean = false>(options: Options<WriteNoteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<WriteNoteResponse, unknown, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/user/{username}/note',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Get users followed by the logged in user
 * Users are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 */
export const apiUserFollowing = <ThrowOnError extends boolean = false>(options?: Options<ApiUserFollowingData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ApiUserFollowingResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/rel/following',
        ...options
    });
};

/**
 * Follow a player
 * Follow a player, adding them to your list of Lichess friends.
 *
 */
export const followUser = <ThrowOnError extends boolean = false>(options: Options<FollowUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<FollowUserResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/rel/follow/{username}',
        ...options
    });
};

/**
 * Unfollow a player
 * Unfollow a player, removing them from your list of Lichess friends.
 *
 */
export const unfollowUser = <ThrowOnError extends boolean = false>(options: Options<UnfollowUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<UnfollowUserResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/rel/unfollow/{username}',
        ...options
    });
};

/**
 * Block a player
 * Block a player, adding them to your list of blocked Lichess users.
 *
 */
export const blockUser = <ThrowOnError extends boolean = false>(options: Options<BlockUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BlockUserResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/rel/block/{username}',
        ...options
    });
};

/**
 * Unblock a player
 * Unblock a player, removing them from your list of blocked Lichess users.
 *
 */
export const unblockUser = <ThrowOnError extends boolean = false>(options: Options<UnblockUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<UnblockUserResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/rel/unblock/{username}',
        ...options
    });
};

/**
 * Stream incoming events
 * Stream the events reaching a lichess user in real time as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 * An empty line is sent every 6 seconds for keep alive purposes.
 *
 * Each non-empty line is a JSON object containing a `type` field. Possible values are:
 * - `gameStart` Start of a game
 * - `gameFinish` Completion of a game
 * - `challenge` A player sends you a challenge or you challenge someone
 * - `challengeCanceled` A player cancels their challenge to you
 * - `challengeDeclined` The opponent declines your challenge
 *
 * When the stream opens, all current challenges and games are sent.
 *
 */
export const apiStreamEvent = <ThrowOnError extends boolean = false>(options?: Options<ApiStreamEventData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ApiStreamEventResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/stream/event',
        ...options
    });
};

/**
 * Create a seek
 * Create a public seek, to start a game with a random player.
 *
 * ### Real-time seek
 *
 * Specify the `time` and `increment` clock values.
 * The response is streamed but doesn't contain any information.
 *
 * **Keep the connection open to keep the seek active**.
 *
 * If the client closes the connection, the seek is canceled. This way, if the client terminates, the user won't be paired in a game they wouldn't play.
 * When the seek is accepted, or expires, the server closes the connection.
 *
 * **Make sure to also have an [Event stream](#operation/apiStreamEvent) open**, to be notified when a game starts.
 * We recommend opening the [Event stream](#operation/apiStreamEvent) first, then the seek stream. This way,
 * you won't miss the game event if the seek is accepted immediately.
 *
 * ### Correspondence seek
 *
 * Specify the `days` per turn value.
 * The response is not streamed, it immediately completes with the seek ID. The seek remains active on the server until it is joined by someone.
 *
 */
export const apiBoardSeek = <ThrowOnError extends boolean = false>(options?: Options<ApiBoardSeekData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ApiBoardSeekResponse, ApiBoardSeekError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/seek',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Stream Board game state
 * Stream the state of a game being played with the Board API, as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 *
 * Use this endpoint to get updates about the game in real-time, with a single request.
 *
 * Each line is a JSON object containing a `type` field. Possible values are:
 * - `gameFull` Full game data. All values are immutable, except for the `state` field.
 * - `gameState` Current state of the game. Immutable values not included. Sent when a move is played, a draw is offered, or when the game ends.
 * - `chatLine` Chat message sent by a user in the `room` "player" or "spectator".
 * - `opponentGone` Whether the opponent has left the game, and how long before you can claim a win or draw.
 *
 * The first line is always of type `gameFull`.
 *
 * The server closes the stream when the game ends, or if the game has already ended.
 *
 */
export const boardGameStream = <ThrowOnError extends boolean = false>(options: Options<BoardGameStreamData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<BoardGameStreamResponse, BoardGameStreamError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/stream/{gameId}',
        ...options
    });
};

/**
 * Make a Board move
 * Make a move in a game being played with the Board API.
 * The move can also contain a draw offer/agreement.
 *
 */
export const boardGameMove = <ThrowOnError extends boolean = false>(options: Options<BoardGameMoveData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BoardGameMoveResponse, BoardGameMoveError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/move/{move}',
        ...options
    });
};

/**
 * Fetch the game chat
 * Get the messages posted in the game chat
 *
 */
export const boardGameChatGet = <ThrowOnError extends boolean = false>(options: Options<BoardGameChatGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<BoardGameChatGetResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/chat',
        ...options
    });
};

/**
 * Write in the chat
 * Post a message to the player or spectator chat, in a game being played with the Board API.
 *
 */
export const boardGameChatPost = <ThrowOnError extends boolean = false>(options: Options<BoardGameChatPostData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BoardGameChatPostResponse, BoardGameChatPostError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/chat',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Abort a game
 * Abort a game being played with the Board API.
 *
 */
export const boardGameAbort = <ThrowOnError extends boolean = false>(options: Options<BoardGameAbortData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BoardGameAbortResponse, BoardGameAbortError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/abort',
        ...options
    });
};

/**
 * Resign a game
 * Resign a game being played with the Board API.
 *
 */
export const boardGameResign = <ThrowOnError extends boolean = false>(options: Options<BoardGameResignData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BoardGameResignResponse, BoardGameResignError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/resign',
        ...options
    });
};

/**
 * Handle draw offers
 * Create/accept/decline draw offers.
 * - `yes`: Offer a draw, or accept the opponent's draw offer.
 * - `no`: Decline a draw offer from the opponent.
 *
 */
export const boardGameDraw = <ThrowOnError extends boolean = false>(options: Options<BoardGameDrawData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BoardGameDrawResponse, BoardGameDrawError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/draw/{accept}',
        ...options
    });
};

/**
 * Handle takeback offers
 * Create/accept/decline takebacks.
 * - `yes`: Propose a takeback, or accept the opponent's takeback offer.
 * - `no`: Decline a takeback offer from the opponent.
 *
 */
export const boardGameTakeback = <ThrowOnError extends boolean = false>(options: Options<BoardGameTakebackData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BoardGameTakebackResponse, BoardGameTakebackError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/takeback/{accept}',
        ...options
    });
};

/**
 * Claim victory of a game
 * Claim victory when the opponent has left the game for a while.
 *
 */
export const boardGameClaimVictory = <ThrowOnError extends boolean = false>(options: Options<BoardGameClaimVictoryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BoardGameClaimVictoryResponse, BoardGameClaimVictoryError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/claim-victory',
        ...options
    });
};

/**
 * Berserk a tournament game
 * Go berserk on an arena tournament game. Halves the clock time, grants an extra point upon winning.
 * Only available in arena tournaments that allow berserk, and before each player has made a move.
 *
 */
export const boardGameBerserk = <ThrowOnError extends boolean = false>(options: Options<BoardGameBerserkData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BoardGameBerserkResponse, BoardGameBerserkError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/board/game/{gameId}/berserk',
        ...options
    });
};

/**
 * Get online bots
 * Stream the [online bot users](https://lichess.org/player/bots), as [ndjson](#section/Introduction/Streaming-with-ND-JSON). Throttled to 50 bot users per second.
 */
export const apiBotOnline = <ThrowOnError extends boolean = false>(options?: Options<ApiBotOnlineData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ApiBotOnlineResponse, unknown, ThrowOnError>({
        url: '/api/bot/online',
        ...options
    });
};

/**
 * Upgrade to Bot account
 * Upgrade a lichess player account into a Bot account. Only Bot accounts can use the Bot API.
 * The account **cannot have played any game** before becoming a Bot account. The upgrade is **irreversible**. The account will only be able to play as a Bot.
 * To upgrade an account to Bot, use the [official lichess-bot client](https://github.com/lichess-bot-devs/lichess-bot), or follow these steps:
 * - Create an [API access token](https://lichess.org/account/oauth/token/create?scopes[]=bot:play) with "Play bot moves" permission.
 * - `curl -d '' https://lichess.org/api/bot/account/upgrade -H "Authorization: Bearer <yourTokenHere>"`
 * To know if an account has already been upgraded, use the [Get my profile API](#operation/accountMe):
 * the `title` field should be set to `BOT`.
 *
 */
export const botAccountUpgrade = <ThrowOnError extends boolean = false>(options?: Options<BotAccountUpgradeData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<BotAccountUpgradeResponse, BotAccountUpgradeError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/account/upgrade',
        ...options
    });
};

/**
 * Stream Bot game state
 * Stream the state of a game being played with the Bot API, as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
 * Use this endpoint to get updates about the game in real-time, with a single request.
 * Each line is a JSON object containing a `type` field. Possible values are:
 * - `gameFull` Full game data. All values are immutable, except for the `state` field.
 * - `gameState` Current state of the game. Immutable values not included.
 * - `chatLine` Chat message sent by a user (or the bot itself) in the `room` "player" or "spectator".
 * - `opponentGone` Whether the opponent has left the game, and how long before you can claim a win or draw.
 * The first line is always of type `gameFull`.
 *
 */
export const botGameStream = <ThrowOnError extends boolean = false>(options: Options<BotGameStreamData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<BotGameStreamResponse, BotGameStreamError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/stream/{gameId}',
        ...options
    });
};

/**
 * Make a Bot move
 * Make a move in a game being played with the Bot API.
 * The move can also contain a draw offer/agreement.
 *
 */
export const botGameMove = <ThrowOnError extends boolean = false>(options: Options<BotGameMoveData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BotGameMoveResponse, BotGameMoveError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/move/{move}',
        ...options
    });
};

/**
 * Fetch the game chat
 * Get the messages posted in the game chat
 *
 */
export const botGameChatGet = <ThrowOnError extends boolean = false>(options: Options<BotGameChatGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<BotGameChatGetResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/chat',
        ...options
    });
};

/**
 * Write in the chat
 * Post a message to the player or spectator chat, in a game being played with the Bot API.
 *
 */
export const botGameChat = <ThrowOnError extends boolean = false>(options: Options<BotGameChatData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BotGameChatResponse, BotGameChatError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/chat',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Abort a game
 * Abort a game being played with the Bot API.
 *
 */
export const botGameAbort = <ThrowOnError extends boolean = false>(options: Options<BotGameAbortData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BotGameAbortResponse, BotGameAbortError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/abort',
        ...options
    });
};

/**
 * Resign a game
 * Resign a game being played with the Bot API.
 *
 */
export const botGameResign = <ThrowOnError extends boolean = false>(options: Options<BotGameResignData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BotGameResignResponse, BotGameResignError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/resign',
        ...options
    });
};

/**
 * Handle draw offers
 * Create/accept/decline draw offers with the Bot API.
 * - `yes`: Offer a draw, or accept the opponent's draw offer.
 * - `no`: Decline a draw offer from the opponent.
 *
 */
export const botGameDraw = <ThrowOnError extends boolean = false>(options: Options<BotGameDrawData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BotGameDrawResponse, BotGameDrawError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/draw/{accept}',
        ...options
    });
};

/**
 * Handle takeback offers
 * Create/accept/decline takebacks with the Bot API.
 * - `yes`: Propose a takeback, or accept the opponent's takeback offer.
 * - `no`: Decline a takeback offer from the opponent.
 *
 */
export const botGameTakeback = <ThrowOnError extends boolean = false>(options: Options<BotGameTakebackData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BotGameTakebackResponse, BotGameTakebackError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/takeback/{accept}',
        ...options
    });
};

/**
 * Claim victory of a game
 * Claim victory when the opponent has left the game for a while.
 *
 */
export const botGameClaimVictory = <ThrowOnError extends boolean = false>(options: Options<BotGameClaimVictoryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BotGameClaimVictoryResponse, BotGameClaimVictoryError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bot/game/{gameId}/claim-victory',
        ...options
    });
};

/**
 * List your challenges
 * Get a list of challenges created by or targeted at you.
 *
 */
export const challengeList = <ThrowOnError extends boolean = false>(options?: Options<ChallengeListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ChallengeListResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge',
        ...options
    });
};

/**
 * Create a challenge
 * Challenge someone to play. The targeted player can choose to accept or decline.
 * If the challenge is accepted, you will be notified on the [event stream](#operation/apiStreamEvent)
 * that a new game has started. The game ID will be the same as the challenge ID.
 * Challenges for realtime games (not correspondence) expire after 20s if not accepted.
 * To prevent that, use the `keepAliveStream` flag described below.
 *
 */
export const challengeCreate = <ThrowOnError extends boolean = false>(options: Options<ChallengeCreateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ChallengeCreateResponse, ChallengeCreateError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge/{username}',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Show one challenge
 * Get details about a challenge, even if it has been recently accepted, canceled or declined.
 *
 */
export const challengeShow = <ThrowOnError extends boolean = false>(options: Options<ChallengeShowData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ChallengeShowResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge/{challengeId}/show',
        ...options
    });
};

/**
 * Accept a challenge
 * Accept an incoming challenge.
 * You should receive a `gameStart` event on the [incoming events stream](#operation/apiStreamEvent).
 *
 */
export const challengeAccept = <ThrowOnError extends boolean = false>(options: Options<ChallengeAcceptData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ChallengeAcceptResponse, ChallengeAcceptError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge/{challengeId}/accept',
        ...options
    });
};

/**
 * Decline a challenge
 * Decline an incoming challenge.
 *
 */
export const challengeDecline = <ThrowOnError extends boolean = false>(options: Options<ChallengeDeclineData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ChallengeDeclineResponse, ChallengeDeclineError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge/{challengeId}/decline',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Cancel a challenge
 * Cancel a challenge you sent, or aborts the game if the challenge was accepted, but the game was not yet played.
 * Note that the ID of a game is the same as the ID of the challenge that created it.
 * Works for user challenges and open challenges alike.
 *
 */
export const challengeCancel = <ThrowOnError extends boolean = false>(options: Options<ChallengeCancelData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ChallengeCancelResponse, ChallengeCancelError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge/{challengeId}/cancel',
        ...options
    });
};

/**
 * Challenge the AI
 * Start a game with Lichess AI.
 * You will be notified on the [event stream](#operation/apiStreamEvent) that a new game has started.
 *
 */
export const challengeAi = <ThrowOnError extends boolean = false>(options: Options<ChallengeAiData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ChallengeAiResponse, ChallengeAiError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge/ai',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Open-ended challenge
 * Create a challenge that any 2 players can join.
 * Share the URL of the challenge. the first 2 players to click it will be paired for a game.
 * The response body also contains `whiteUrl` and `blackUrl`.
 * You can control which color each player gets by giving them these URLs,
 * instead of the main challenge URL.
 * Open challenges expire after 24h.
 * If the challenge creation is [authenticated with OAuth2](#section/Introduction/Authentication),
 * then you can use the [challenge cancel endpoint](#operation/challengeCancel) to cancel it.
 * To directly pair 2 known players, use [this endpoint](#operation/bulkPairingList) instead.
 *
 */
export const challengeOpen = <ThrowOnError extends boolean = false>(options?: Options<ChallengeOpenData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ChallengeOpenResponse, ChallengeOpenError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        url: '/api/challenge/open',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Start clocks of a game
 * Start the clocks of a game immediately, even if a player has not yet made a move.
 * Requires the OAuth tokens of both players with `challenge:write` scope.
 * If the clocks have already started, the call will have no effect.
 *
 * For AI games with only one player, omit the `token2` parameter.
 *
 */
export const challengeStartClocks = <ThrowOnError extends boolean = false>(options: Options<ChallengeStartClocksData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ChallengeStartClocksResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/challenge/{gameId}/start-clocks',
        ...options
    });
};

/**
 * View your bulk pairings
 * Get a list of bulk pairings you created.
 *
 */
export const bulkPairingList = <ThrowOnError extends boolean = false>(options?: Options<BulkPairingListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<BulkPairingListResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bulk-pairing',
        ...options
    });
};

/**
 * Create a bulk pairing
 * Schedule many games at once, up to 24h in advance.
 * OAuth tokens are required for all paired players, with the `challenge:write` scope.
 * You can schedule up to 500 games every 10 minutes. [Contact us](mailto:contact@lichess.org) if you need higher limits.
 * If games have a real-time clock, each player must have only one pairing.
 * For correspondence games, players can have multiple pairings within the same bulk.
 *
 * **The entire bulk is rejected if:**
 * - a token is missing
 * - a token is present more than once (except in correspondence)
 * - a token lacks the `challenge:write` scope
 * - a player account is closed
 * - a player is paired more than once (except in correspondence)
 * - a bulk is already scheduled to start at the same time with the same player
 * - you have 20 scheduled bulks
 * - you have 1000 scheduled games
 *
 * Partial bulks are never created. Either it all fails, or it all succeeds.
 * When it fails, it does so with an error message explaining the issue.
 * Failed bulks are not counted in the rate limiting, they are free.
 * Fix the issues, manually or programmatically, then retry to schedule the bulk.
 * A successful bulk creation returns a JSON bulk document. Its ID can be used for further operations.
 *
 */
export const bulkPairingCreate = <ThrowOnError extends boolean = false>(options: Options<BulkPairingCreateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BulkPairingCreateResponse, BulkPairingCreateError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bulk-pairing',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Manually start clocks
 * Immediately start all clocks of the games of a bulk pairing.
 * This overrides the `startClocksAt` value of an existing bulk pairing.
 * If the games have not yet been created (`bulk.pairAt` is in the future), then this does nothing.
 * If the clocks have already started (`bulk.startClocksAt` is in the past), then this does nothing.
 *
 */
export const bulkPairingStartClocks = <ThrowOnError extends boolean = false>(options: Options<BulkPairingStartClocksData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BulkPairingStartClocksResponse, BulkPairingStartClocksError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bulk-pairing/{id}/start-clocks',
        ...options
    });
};

/**
 * Cancel a bulk pairing
 * Cancel and delete a bulk pairing that is scheduled in the future.
 * If the games have already been created, then this does nothing.
 * Canceling a bulk pairing does not refund the rate limit cost of that bulk pairing.
 *
 */
export const bulkPairingDelete = <ThrowOnError extends boolean = false>(options: Options<BulkPairingDeleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<BulkPairingDeleteResponse, BulkPairingDeleteError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bulk-pairing/{id}',
        ...options
    });
};

/**
 * Show a bulk pairing
 * Get a single bulk pairing by its ID.
 *
 */
export const bulkPairingGet = <ThrowOnError extends boolean = false>(options: Options<BulkPairingGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<BulkPairingGetResponse, BulkPairingGetError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bulk-pairing/{id}',
        ...options
    });
};

/**
 * Export games of a bulk pairing
 * Download games of a bulk in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
 *
 */
export const bulkPairingIdGamesGet = <ThrowOnError extends boolean = false>(options: Options<BulkPairingIdGamesGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<BulkPairingIdGamesGetResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/bulk-pairing/{id}/games',
        ...options
    });
};

/**
 * Add time to the opponent clock
 * Add seconds to the opponent's clock. Can be used to create games with time odds.
 *
 */
export const roundAddTime = <ThrowOnError extends boolean = false>(options: Options<RoundAddTimeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RoundAddTimeResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/round/{gameId}/add-time/{seconds}',
        ...options
    });
};

/**
 * Admin challenge tokens
 * **This endpoint can only be used by Lichess administrators. It will not work if you do not have the appropriate permissions.** Tournament organizers should instead use [OAuth](#tag/OAuth) to obtain `challenge:write` tokens from users in order to perform bulk pairing.*
 * Create and obtain `challenge:write` tokens for multiple users.
 * If a similar token already exists for a user, it is reused. This endpoint is idempotent.
 *
 */
export const adminChallengeTokens = <ThrowOnError extends boolean = false>(options: Options<AdminChallengeTokensData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<AdminChallengeTokensResponse, AdminChallengeTokensError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/token/admin-challenge',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Send a private message
 * Send a private message to another player.
 *
 */
export const inboxUsername = <ThrowOnError extends boolean = false>(options: Options<InboxUsernameData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<InboxUsernameResponse, InboxUsernameError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/inbox/{username}',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Get cloud evaluation of a position.
 * Get the cached evaluation of a position, if available.
 * Opening positions have more chances of being available. There are about 15 million positions in the database.
 * Up to 5 variations may be available. Variants are supported.
 * Use this endpoint to fetch a few positions here and there.
 * If you want to download a lot of positions, [get the full list](https://database.lichess.org/#evals) from our exported database.
 *
 */
export const apiCloudEval = <ThrowOnError extends boolean = false>(options: Options<ApiCloudEvalData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiCloudEvalResponse, ApiCloudEvalError, ThrowOnError>({
        url: '/api/cloud-eval',
        ...options
    });
};

/**
 * List external engines
 * Lists all external engines that have been registered for the user,
 * and the credentials required to use them.
 *
 */
export const apiExternalEngineList = <ThrowOnError extends boolean = false>(options?: Options<ApiExternalEngineListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ApiExternalEngineListResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/external-engine',
        ...options
    });
};

/**
 * Create external engine
 * Registers a new external engine for the user. It can then be selected
 * and used on the analysis board.
 * After registering, the provider should start waiting for analyis requests.
 *
 */
export const apiExternalEngineCreate = <ThrowOnError extends boolean = false>(options: Options<ApiExternalEngineCreateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiExternalEngineCreateResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/external-engine',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete external engine
 * Unregisters an external engine.
 *
 */
export const apiExternalEngineDelete = <ThrowOnError extends boolean = false>(options: Options<ApiExternalEngineDeleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<ApiExternalEngineDeleteResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/external-engine/{id}',
        ...options
    });
};

/**
 * Get external engine
 * Get properties and credentials of an external engine.
 *
 */
export const apiExternalEngineGet = <ThrowOnError extends boolean = false>(options: Options<ApiExternalEngineGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ApiExternalEngineGetResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/external-engine/{id}',
        ...options
    });
};

/**
 * Update external engine
 * Updates the properties of an external engine.
 *
 */
export const apiExternalEnginePut = <ThrowOnError extends boolean = false>(options: Options<ApiExternalEnginePutData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<ApiExternalEnginePutResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/external-engine/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Analyse with external engine
 * **Endpoint: `https://engine.lichess.ovh/api/external-engine/{id}/analyse`**
 * Request analysis from an external engine.
 * Response content is streamed as [newline delimited JSON](#section/Introduction/Streaming-with-ND-JSON).
 * The properties are based on the [UCI specification](https://backscattering.de/chess/uci/#engine).
 * Analysis stops when the client goes away, the requested limit
 * is reached, or the provider goes away.
 *
 */
export const apiExternalEngineAnalyse = <ThrowOnError extends boolean = false>(options: Options<ApiExternalEngineAnalyseData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiExternalEngineAnalyseResponse, unknown, ThrowOnError>({
        url: '/api/external-engine/{id}/analyse',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Acquire analysis request
 * **Endpoint: `https://engine.lichess.ovh/api/external-engine/work`**
 * Wait for an analysis requests to any of the external engines that
 * have been registered with the given `secret`.
 * Uses long polling.
 * After acquiring a request, the provider should immediately
 * [start streaming the results](#tag/External-engine/operation/apiExternalEngineSubmit).
 *
 */
export const apiExternalEngineAcquire = <ThrowOnError extends boolean = false>(options: Options<ApiExternalEngineAcquireData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiExternalEngineAcquireResponse, unknown, ThrowOnError>({
        url: '/api/external-engine/work',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Answer analysis request
 * **Endpoint: `https://engine.lichess.ovh/api/external-engine/work/{id}`**
 * Submit a stream of analysis as [UCI output](https://backscattering.de/chess/uci/#engine-info).
 * * The engine should always be in `UCI_Chess960` mode.
 * * `UCI_AnalyseMode` enabled if available.
 * * It produces `info` with at least:
 * - `depth`
 * - `multipv` (between 1 and 5)
 * - `score`
 * - `nodes`
 * - `time`
 * - `pv`
 * The server may close the connection at any time, indicating that
 * the requester has gone away and analysis should be stopped.
 *
 */
export const apiExternalEngineSubmit = <ThrowOnError extends boolean = false>(options: Options<ApiExternalEngineSubmitData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<unknown, unknown, ThrowOnError>({
        bodySerializer: null,
        url: '/api/external-engine/work/{id}',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};

/**
 * Request authorization code
 * OAuth2 authorization endpoint.
 * Start the OAuth2 Authorization Code Flow with PKCE by securely
 * generating two random strings unique to each authorization
 * request:
 *
 * * `code_verifier`
 * * `state`
 *
 * Store these in session storage. Make sure not to reveal `code_verifier`
 * to eavesdroppers. Do not show it in URLs, do not abuse `state` to store
 * it, do not send it over insecure connections. However it is fine if
 * the user themselves can extract `code_verifier`, which will always be
 * possible for fully client-side apps.
 * Then send the user to this endpoint. They will be prompted to grant
 * authorization and then be redirected back to the given `redirect_uri`.
 * If the authorization failed, the following query string parameters will
 * be appended to the redirection:
 *
 * * `error`, in particular with value `access_denied` if the user
 * cancelled authorization
 * * `error_description` to aid debugging
 * * `state`, exactly as passed in the `state` parameter
 *
 * If the authorization succeeded, the following query string parameters
 * will be appended to the redirection:
 *
 * * `code`, containing a fresh short-lived authorization code
 * * `state`, exactly as passed in the `state` parameter
 *
 * Next, to defend against cross site request forgery, check that the
 * returned `state` matches the `state` you originally generated.
 *
 * Finally, continue by using the authorization code to
 * [obtain an access token](#operation/apiToken).
 *
 */
export const oauth = <ThrowOnError extends boolean = false>(options: Options<OauthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        url: '/oauth',
        ...options
    });
};

/**
 * Revoke access token
 * Revokes the access token sent as Bearer for this request.
 */
export const apiTokenDelete = <ThrowOnError extends boolean = false>(options?: Options<ApiTokenDeleteData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).delete<ApiTokenDeleteResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/api/token',
        ...options
    });
};

/**
 * Obtain access token
 * OAuth2 token endpoint. Exchanges an authorization code for an access token.
 *
 */
export const apiToken = <ThrowOnError extends boolean = false>(options: Options<ApiTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ApiTokenResponse, ApiTokenError, ThrowOnError>({
        ...urlSearchParamsBodySerializer,
        url: '/api/token',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options?.headers
        }
    });
};

/**
 * Test multiple OAuth tokens
 * For up to 1000 OAuth tokens,
 * returns their associated user ID and scopes,
 * or `null` if the token is invalid.
 * The method is `POST` so a longer list of tokens can be sent in the request body.
 *
 */
export const tokenTest = <ThrowOnError extends boolean = false>(options: Options<TokenTestData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<TokenTestResponse, unknown, ThrowOnError>({
        bodySerializer: null,
        url: '/api/token/test',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};

/**
 * Masters database
 * **Endpoint: <https://explorer.lichess.ovh/masters>**
 *
 * Example: `curl https://explorer.lichess.ovh/masters?play=d2d4,d7d5,c2c4,c7c6,c4d5`
 *
 */
export const openingExplorerMaster = <ThrowOnError extends boolean = false>(options?: Options<OpeningExplorerMasterData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<OpeningExplorerMasterResponse, unknown, ThrowOnError>({
        url: '/masters',
        ...options
    });
};

/**
 * Lichess games
 * **Endpoint: <https://explorer.lichess.ovh/lichess>**
 *
 * Games sampled from all Lichess players.
 *
 * Example: `curl https://explorer.lichess.ovh/lichess?variant=standard&speeds=blitz,rapid,classical&ratings=2200,2500&fen=rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR%20w%20KQkq%20-%200%201`
 *
 */
export const openingExplorerLichess = <ThrowOnError extends boolean = false>(options?: Options<OpeningExplorerLichessData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<OpeningExplorerLichessResponse, unknown, ThrowOnError>({
        url: '/lichess',
        ...options
    });
};

/**
 * Player games
 * **Endpoint: <https://explorer.lichess.ovh/player>**
 *
 * Games of a Lichess player.
 *
 * Responds with a stream of [newline delimited JSON](#section/Introduction/Streaming-with-ND-JSON). Will start indexing
 * on demand, immediately respond with the current results, and stream
 * more updates until indexing is complete. The stream is throttled
 * and deduplicated. Empty lines may be sent to avoid timeouts.
 *
 * Will index new games at most once per minute, and revisit previously
 * ongoing games at most once every day.
 *
 * Example: `curl https://explorer.lichess.ovh/player?player=revoof&color=white&play=d2d4,d7d5&recentGames=1`
 *
 */
export const openingExplorerPlayer = <ThrowOnError extends boolean = false>(options: Options<OpeningExplorerPlayerData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<OpeningExplorerPlayerResponse, unknown, ThrowOnError>({
        url: '/player',
        ...options
    });
};

/**
 * OTB master game
 * **Endpoint: `https://explorer.lichess.ovh/masters/pgn/{gameId}`**
 *
 * Example: `curl https://explorer.lichess.ovh/masters/pgn/aAbqI4ey`
 *
 */
export const openingExplorerMasterGame = <ThrowOnError extends boolean = false>(options: Options<OpeningExplorerMasterGameData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<OpeningExplorerMasterGameResponse, unknown, ThrowOnError>({
        url: '/master/pgn/{gameId}',
        ...options
    });
};

/**
 * Tablebase lookup
 * **Endpoint: <https://tablebase.lichess.ovh>**
 * Example: `curl http://tablebase.lichess.ovh/standard?fen=4k3/6KP/8/8/8/8/7p/8_w_-_-_0_1`
 *
 */
export const tablebaseStandard = <ThrowOnError extends boolean = false>(options: Options<TablebaseStandardData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<TablebaseStandardResponse, unknown, ThrowOnError>({
        url: '/standard',
        ...options
    });
};

/**
 * Tablebase lookup for Atomic chess
 * **Endpoint: <https://tablebase.lichess.ovh>**
 *
 */
export const tablebaseAtomic = <ThrowOnError extends boolean = false>(options?: Options<TablebaseAtomicData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<TablebaseAtomicResponse, unknown, ThrowOnError>({
        url: '/atomic',
        ...options
    });
};

/**
 * Tablebase lookup for Antichess
 * **Endpoint: <https://tablebase.lichess.ovh>**
 *
 */
export const antichessAtomic = <ThrowOnError extends boolean = false>(options?: Options<AntichessAtomicData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<AntichessAtomicResponse, unknown, ThrowOnError>({
        url: '/antichess',
        ...options
    });
};