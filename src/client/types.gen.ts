// This file is auto-generated by @hey-api/openapi-ts

export type Top10S = unknown;

export type Leaderboard = unknown;

export type Perf = {
    games?: number;
    rating?: number;
    rd?: number;
    prog?: number;
    /**
     * only appears if a user's perf rating are [provisional](https://lichess.org/faq#provisional)
     */
    prov?: boolean;
};

export type PuzzleModePerf = {
    runs?: number;
    score?: number;
};

export type Perfs = {
    chess960?: Perf;
    atomic?: Perf;
    racingKings?: Perf;
    ultraBullet?: Perf;
    blitz?: Perf;
    kingOfTheHill?: Perf;
    bullet?: Perf;
    correspondence?: Perf;
    horde?: Perf;
    puzzle?: Perf;
    classical?: Perf;
    rapid?: Perf;
    storm?: PuzzleModePerf;
    racer?: PuzzleModePerf;
    streak?: PuzzleModePerf;
};

/**
 * See [available flair list and images](https://github.com/lichess-org/lila/tree/master/public/flair)
 */
export type Flair = string;

export type Profile = {
    flag?: string;
    location?: string;
    bio?: string;
    realName?: string;
    /**
     * only appears if a user has set them
     */
    fideRating?: number;
    /**
     * only appears if a user has set them
     */
    uscfRating?: number;
    /**
     * only appears if a user has set them
     */
    ecfRating?: number;
    /**
     * only appears if a user has set them
     */
    cfcRating?: number;
    /**
     * only appears if a user has set them
     */
    dsbRating?: number;
    links?: string;
};

export type PlayTime = {
    total?: number;
    tv?: number;
};

/**
 * only appears if the user is a titled player or a bot user
 */
export type Title = 'GM' | 'WGM' | 'IM' | 'WIM' | 'FM' | 'WFM' | 'NM' | 'CM' | 'WCM' | 'WNM' | 'LM' | 'BOT';

export type User = {
    id: string;
    username: string;
    perfs?: Perfs;
    flair?: Flair;
    createdAt?: number;
    /**
     * only appears if a user's account is closed
     */
    disabled?: boolean;
    /**
     * only appears if a user's account is marked for the violation of [Lichess TOS](https://lichess.org/terms-of-service)
     */
    tosViolation?: boolean;
    profile?: Profile;
    seenAt?: number;
    patron?: boolean;
    verified?: boolean;
    playTime?: PlayTime;
    title?: Title;
};

export type Count = {
    all?: number;
    rated?: number;
    ai?: number;
    draw?: number;
    drawH?: number;
    loss?: number;
    lossH?: number;
    win?: number;
    winH?: number;
    bookmark?: number;
    playing?: number;
    import?: number;
    me?: number;
};

export type UserExtended = User & {
    url?: string;
    playing?: string;
    count?: Count;
    streaming?: boolean;
    streamer?: {
        twitch?: {
            channel?: string;
        };
        youTube?: {
            channel?: string;
        };
    };
    /**
     * only appears if the request is [authenticated with OAuth2](#section/Introduction/Authentication)
     */
    followable?: boolean;
    /**
     * only appears if the request is [authenticated with OAuth2](#section/Introduction/Authentication)
     */
    following?: boolean;
    /**
     * only appears if the request is [authenticated with OAuth2](#section/Introduction/Authentication)
     */
    blocking?: boolean;
};

export type RatingHistory = unknown;

export type PerfType = 'ultraBullet' | 'bullet' | 'blitz' | 'rapid' | 'classical' | 'correspondence' | 'chess960' | 'crazyhouse' | 'antichess' | 'atomic' | 'horde' | 'kingOfTheHill' | 'racingKings' | 'threeCheck';

export type PerfStat = unknown;

export type UserActivityScore = {
    win: number;
    loss: number;
    draw: number;
    rp: {
        before?: number;
        after?: number;
    };
};

export type VariantKey = 'standard' | 'chess960' | 'crazyhouse' | 'antichess' | 'atomic' | 'horde' | 'kingOfTheHill' | 'racingKings' | 'threeCheck' | 'fromPosition';

export type UserActivityCorrespondenceGame = {
    id: string;
    color: 'white' | 'black';
    url: string;
    variant: VariantKey;
    speed: 'correspondence';
    perf: 'correspondence';
    rated: boolean;
    opponent: {
        user: string;
        rating: number;
    };
};

export type UserActivityFollowList = {
    ids: Array<string>;
    nb?: number;
};

export type UserActivity = {
    interval: {
        start: number;
        end: number;
    };
    games?: {
        chess960?: UserActivityScore;
        atomic?: UserActivityScore;
        racingKings?: UserActivityScore;
        ultraBullet?: UserActivityScore;
        blitz?: UserActivityScore;
        kingOfTheHill?: UserActivityScore;
        bullet?: UserActivityScore;
        correspondence?: UserActivityScore;
        horde?: UserActivityScore;
        puzzle?: UserActivityScore;
        classical?: UserActivityScore;
        rapid?: UserActivityScore;
    };
    puzzles?: {
        score?: UserActivityScore;
    };
    storm?: {
        runs?: number;
        score?: number;
    };
    racer?: {
        runs?: number;
        score?: number;
    };
    streak?: {
        runs?: number;
        score?: number;
    };
    tournaments?: {
        nb?: number;
        best?: Array<{
            tournament: {
                id: string;
                name: string;
            };
            nbGames: number;
            score: number;
            rank: number;
            rankPercent: number;
        }>;
    };
    practice?: Array<{
        url: string;
        name: string;
        nbPositions: number;
    }>;
    simuls?: Array<string>;
    correspondenceMoves?: {
        nb: number;
        games: Array<UserActivityCorrespondenceGame>;
    };
    correspondenceEnds?: {
        score: UserActivityScore;
        games: Array<UserActivityCorrespondenceGame>;
    };
    follows?: {
        in?: UserActivityFollowList;
        out?: UserActivityFollowList;
    };
    studies?: {
        [key: string]: unknown;
    };
    teams?: Array<{
        url: string;
        name: string;
    }>;
    posts?: Array<{
        topicUrl: string;
        topicName: string;
        posts: Array<{
            url: string;
            text: string;
        }>;
    }>;
    patron?: {
        months: number;
    };
    stream?: boolean;
};

export type PuzzleAndGame = {
    game: {
        clock: string;
        id: string;
        perf: {
            key: PerfType;
            name: string;
        };
        pgn: string;
        players: Array<{
            color: string;
            flair?: Flair;
            id: string;
            name: string;
            patron?: boolean;
            rating: number;
            title?: Title;
        }>;
        rated: boolean;
    };
    puzzle: {
        id: string;
        initialPly: number;
        plays: number;
        rating: number;
        solution: Array<string>;
        themes: Array<string>;
    };
};

export type PuzzleActivity = {
    date: number;
    puzzle: {
        fen: string;
        id: string;
        lastMove: string;
        plays: number;
        rating: number;
        solution: Array<string>;
        themes: Array<string>;
    };
    win: boolean;
};

export type PuzzleReplay = {
    replay: {
        days: number;
        theme: string;
        nb: number;
        remaining: Array<string>;
    };
    angle: {
        key: string;
        name: string;
        desc: string;
    };
};

export type PuzzlePerformance = {
    firstWins: number;
    nb: number;
    performance: number;
    puzzleRatingAvg: number;
    replayWins: number;
};

export type PuzzleDashboard = {
    days: number;
    global: PuzzlePerformance;
    themes: {
        [key: string]: {
            results: PuzzlePerformance;
            theme: string;
        };
    };
};

export type PuzzleStormDashboard = {
    days: Array<{
        _id: string;
        combo: number;
        errors: number;
        highest: number;
        moves: number;
        runs: number;
        score: number;
        time: number;
    }>;
    high: {
        allTime: number;
        day: number;
        month: number;
        week: number;
    };
};

export type PuzzleRacer = {
    id: string;
    url: string;
};

export type UserPreferences = {
    dark?: boolean;
    transp?: boolean;
    bgImg?: string;
    is3d?: boolean;
    theme?: 'blue' | 'blue2' | 'blue3' | 'blue-marble' | 'canvas' | 'wood' | 'wood2' | 'wood3' | 'wood4' | 'maple' | 'maple2' | 'brown' | 'leather' | 'green' | 'marble' | 'green-plastic' | 'grey' | 'metal' | 'olive' | 'newspaper' | 'purple' | 'purple-diag' | 'pink' | 'ic';
    pieceSet?: 'cburnett' | 'merida' | 'alpha' | 'pirouetti' | 'chessnut' | 'chess7' | 'reillycraig' | 'companion' | 'riohacha' | 'kosal' | 'leipzig' | 'fantasy' | 'spatial' | 'california' | 'pixel' | 'maestro' | 'fresca' | 'cardinal' | 'gioco' | 'tatiana' | 'staunty' | 'governor' | 'dubrovny' | 'icpieces' | 'shapes' | 'letter';
    theme3d?: 'Black-White-Aluminium' | 'Brushed-Aluminium' | 'China-Blue' | 'China-Green' | 'China-Grey' | 'China-Scarlet' | 'Classic-Blue' | 'Gold-Silver' | 'Light-Wood' | 'Power-Coated' | 'Rosewood' | 'Marble' | 'Wax' | 'Jade' | 'Woodi';
    pieceSet3d?: 'Basic' | 'Wood' | 'Metal' | 'RedVBlue' | 'ModernJade' | 'ModernWood' | 'Glass' | 'Trimmed' | 'Experimental' | 'Staunton' | 'CubesAndPi';
    soundSet?: 'silent' | 'standard' | 'piano' | 'nes' | 'sfx' | 'futuristic' | 'robot' | 'music' | 'speech';
    blindfold?: number;
    autoQueen?: number;
    autoThreefold?: number;
    takeback?: number;
    moretime?: number;
    clockTenths?: number;
    clockBar?: boolean;
    clockSound?: boolean;
    premove?: boolean;
    animation?: number;
    captured?: boolean;
    follow?: boolean;
    highlight?: boolean;
    destination?: boolean;
    coords?: number;
    replay?: number;
    challenge?: number;
    message?: number;
    coordColor?: number;
    submitMove?: number;
    confirmResign?: number;
    insightShare?: number;
    keyboardMove?: number;
    zen?: number;
    moveEvent?: number;
    rookCastle?: number;
};

export type Ok = {
    ok?: boolean;
};

export type TimelineEntryFollow = {
    type: 'follow';
    date: number;
    data: {
        u1: string;
        u2: string;
    };
};

export type TimelineEntryTeamJoin = {
    type: 'team-join';
    date: number;
    data: {
        userId: string;
        teamId: string;
    };
};

export type TimelineEntryTeamCreate = {
    type: 'team-create';
    date: number;
    data: {
        userId: string;
        teamId: string;
    };
};

export type TimelineEntryForumPost = {
    type: 'forum-post';
    date: number;
    data: {
        userId: string;
        topicId: string;
        topicName: string;
        postId: string;
    };
};

export type TimelineEntryBlogPost = {
    type: 'blog-post';
    date: number;
    data: {
        id: string;
        slug: string;
        title: string;
    };
};

export type TimelineEntryUblogPost = {
    type: 'ublog-post';
    date: number;
    data: {
        userId: string;
        id: string;
        slug: string;
        title: string;
    };
};

export type TimelineEntryTourJoin = {
    type: 'tour-join';
    date: number;
    data: {
        userId: string;
        tourId: string;
        tourName: string;
    };
};

export type TimelineEntryGameEnd = {
    type: 'game-end';
    date: number;
    data: {
        fullId: string;
        opponent: string;
        win: boolean;
        perf: PerfType;
    };
};

export type TimelineEntrySimul = {
    type: 'simul-create' | 'simul-join';
    date: number;
    data: {
        userId: string;
        simulId: string;
        simulName: string;
    };
};

export type TimelineEntryStudyLike = {
    type: 'study-like';
    date: number;
    data: {
        userId: string;
        studyId: string;
        studyName: string;
    };
};

export type TimelineEntryPlanStart = {
    type: 'plan-start';
    date: number;
    data: {
        userId: string;
    };
};

export type TimelineEntryPlanRenew = {
    type: 'plan-renew';
    date: number;
    data: {
        userId: string;
        months: number;
    };
};

export type TimelineEntryUblogPostLike = {
    type: 'ublog-post-like';
    date: number;
    data: {
        userId: string;
        id: string;
        title: string;
    };
};

export type TimelineEntryStreamStart = {
    type: 'stream-start';
    date: number;
    data: {
        id: string;
        name?: string;
    };
};

export type Timeline = {
    entries: Array<({
        type?: 'follow';
    } & TimelineEntryFollow) | ({
        type?: 'team-join';
    } & TimelineEntryTeamJoin) | ({
        type?: 'team-create';
    } & TimelineEntryTeamCreate) | ({
        type?: 'forum-post';
    } & TimelineEntryForumPost) | ({
        type?: 'blog-post';
    } & TimelineEntryBlogPost) | ({
        type?: 'ublog-post';
    } & TimelineEntryUblogPost) | ({
        type?: 'tour-join';
    } & TimelineEntryTourJoin) | ({
        type?: 'game-end';
    } & TimelineEntryGameEnd) | ({
        type?: 'simul-create';
    } & TimelineEntrySimul) | ({
        type?: 'study-like';
    } & TimelineEntryStudyLike) | ({
        type?: 'plan-start';
    } & TimelineEntryPlanStart) | ({
        type?: 'plan-renew';
    } & TimelineEntryPlanRenew) | ({
        type?: 'ublog-post-like';
    } & TimelineEntryUblogPostLike) | ({
        type?: 'stream-start';
    } & TimelineEntryStreamStart)>;
    users: {
        [key: string]: {
            id: string;
            name: string;
            title?: Title;
            patron?: boolean;
        };
    };
};

export type GamePgn = string;

export type Speed = 'ultraBullet' | 'bullet' | 'blitz' | 'rapid' | 'classical' | 'correspondence';

/**
 * Game status code. https://github.com/lichess-org/scalachess/blob/0a7d6f2c63b1ca06cd3c958ed3264e738af5c5f6/src/main/scala/Status.scala#L16-L28
 */
export type GameStatus = 'created' | 'started' | 'aborted' | 'mate' | 'resign' | 'stalemate' | 'timeout' | 'draw' | 'outoftime' | 'cheat' | 'noStart' | 'unknownFinish' | 'variantEnd';

export type LightUser = {
    id: string;
    name: string;
    title?: Title;
    patron?: boolean;
};

export type GameUser = {
    user?: LightUser;
    rating?: number;
    ratingDiff?: number;
    name?: string;
    provisional?: boolean;
    aiLevel?: number;
    analysis?: {
        inaccuracy: number;
        mistake: number;
        blunder: number;
        acpl: number;
        accuracy?: number;
    };
    team?: string;
};

export type GameMoveAnalysis = {
    /**
     * Evaluation in centipawns
     */
    eval?: number;
    /**
     * Number of moves until forced mate
     */
    mate?: number;
    /**
     * Best move in UCI notation (only if played move was inaccurate)
     */
    best?: string;
    /**
     * Best variation in SAN notation (only if played move was inaccurate)
     */
    variation?: string;
    /**
     * Judgment annotation (only if played move was inaccurate)
     */
    judgment?: {
        name?: 'Inaccuracy' | 'Mistake' | 'Blunder';
        comment?: string;
    };
};

export type GameJson = {
    id: string;
    rated: boolean;
    variant: VariantKey;
    speed: Speed;
    perf: string;
    createdAt: number;
    lastMoveAt: number;
    status: GameStatus;
    players: {
        white: GameUser;
        black: GameUser;
    };
    initialFen?: string;
    winner?: 'white' | 'black';
    opening?: {
        eco?: string;
        name?: string;
        ply?: number;
    };
    moves?: string;
    pgn?: string;
    daysPerTurn?: number;
    analysis?: Array<GameMoveAnalysis>;
    tournament?: string;
    swiss?: string;
    clock?: {
        initial: number;
        increment: number;
        totalTime: number;
    };
    clocks?: Array<number>;
    division?: {
        /**
         * Ply at which the middlegame begins
         */
        middle?: number;
        /**
         * Ply at which the endgame begins
         */
        end?: number;
    };
};

export type GameStream = unknown;

export type GameSource = 'lobby' | 'friend' | 'ai' | 'api' | 'tournament' | 'position' | 'import' | 'importlive' | 'simul' | 'relay' | 'pool' | 'swiss';

export type Variant = {
    key?: VariantKey;
    name?: string;
    short?: string;
};

export type MoveStream = unknown;

export type TvGame = {
    user: LightUser & {
        flair?: Flair;
    };
    rating: number;
    gameId: string;
    color: 'white' | 'black';
};

export type TvFeed = {
    /**
     * The type of message.
     * A summary of the game is sent as the first message and when the featured game changes.
     * Subsequent messages are just the FEN, last move, and clocks.
     *
     */
    t: 'featured' | 'fen';
    /**
     * The data of the message
     */
    d: {
        /**
         * The game ID
         */
        id: string;
        orientation: 'white' | 'black';
        players: [
            {
                color: 'white' | 'black';
                user: {
                    name: string;
                    id: string;
                    title?: string;
                };
                rating: number;
                /**
                 * The player's remaining time in seconds
                 */
                seconds: number;
            },
            {
                color: 'white' | 'black';
                user: {
                    name: string;
                    id: string;
                    title?: string;
                };
                rating: number;
                /**
                 * The player's remaining time in seconds
                 */
                seconds: number;
            }
        ];
        /**
         * The FEN of the current position
         */
        fen: string;
    } | {
        /**
         * The FEN of the current position
         */
        fen: string;
        /**
         * The last move in UCI format
         */
        lm: string;
        /**
         * White's clock in seconds
         */
        wc: number;
        /**
         * Black's clock in seconds
         */
        bc: number;
    };
};

export type Clock = {
    limit?: number;
    increment?: number;
};

/**
 * 10: created, 20: started, 30: finished
 *
 */
export type ArenaStatus = 10 | 20 | 30;

export type ArenaPerf = {
    key?: string;
    name?: string;
    position?: number;
    icon?: string;
};

export type ArenaRatingObj = {
    perf?: PerfType;
    rating?: number;
};

export type ArenaPosition = {
    eco?: string;
    name?: string;
    fen?: string;
    url?: string;
} | {
    name?: 'Custom position';
    fen?: string;
};

export type ArenaTournament = {
    id?: string;
    createdBy?: string;
    system?: 'arena';
    minutes?: number;
    clock?: Clock;
    rated?: boolean;
    fullName?: string;
    nbPlayers?: number;
    variant?: Variant;
    startsAt?: number;
    finishesAt?: number;
    status?: ArenaStatus;
    perf?: ArenaPerf;
    secondsToStart?: number;
    hasMaxRating?: boolean;
    maxRating?: ArenaRatingObj;
    minRating?: ArenaRatingObj;
    minRatedGames?: {
        nb?: number;
    };
    botsAllowed?: boolean;
    minAccountAgeInDays?: number;
    onlyTitled?: boolean;
    teamMember?: string;
    private?: boolean;
    position?: ArenaPosition;
    schedule?: {
        freq?: string;
        speed?: string;
    };
    teamBattle?: {
        teams?: Array<string>;
        nbLeaders?: number;
    };
    winner?: {
        id?: string;
        name?: string;
        title?: Title;
    };
};

export type ArenaTournaments = {
    created?: Array<ArenaTournament>;
    started?: Array<ArenaTournament>;
    finished?: Array<ArenaTournament>;
};

/**
 * Custom initial position (in FEN). Variant must be standard, fromPosition, or chess960 (if a valid 960 starting position), and the game cannot be rated.
 */
export type FromPositionFen = string;

export type Verdicts = {
    accepted: boolean;
    list: Array<{
        condition: string;
        verdict: string;
    }>;
};

export type ArenaSheet = {
    scores: string;
    fire?: boolean;
};

export type ArenaPlayerPerformance = {
    name?: string;
    rank?: number;
    title?: string;
    patron?: boolean;
    rating?: number;
    score?: number;
    flair?: Flair;
    sheet?: ArenaSheet;
    nb?: {
        game?: number;
        beserk?: number;
        win?: number;
    };
    performance?: number;
};

export type ArenaTournamentFull = {
    id: string;
    fullName: string;
    rated?: boolean;
    spotlight?: {
        headline?: string;
    };
    berserkable?: boolean;
    onlyTitled?: boolean;
    clock: {
        increment: number;
        limit: number;
    };
    minutes?: number;
    createdBy?: string;
    system?: string;
    secondsToStart?: number;
    secondsToFinish?: number;
    isFinished: boolean;
    isRecentlyFinished?: boolean;
    pairingsClosed?: boolean;
    startsAt?: string;
    nbPlayers: number;
    verdicts?: Verdicts;
    /**
     * The quote displayed on the tournament page
     */
    quote?: {
        text?: string;
        author?: string;
    };
    /**
     * List of usernames allowed to join the tournament
     */
    allowList?: Array<string>;
    hasMaxRating?: boolean;
    maxRating?: ArenaRatingObj;
    minRating?: ArenaRatingObj;
    minRatedGames?: {
        nb?: number;
    };
    botsAllowed?: boolean;
    minAccountAgeInDays?: number;
    perf?: {
        icon: string;
        key: string;
        name: string;
    };
    schedule?: {
        freq: string;
        speed: string;
    };
    variant?: string;
    duels?: Array<{
        id?: string;
        p?: [
            {
                n?: string;
                r?: number;
                k?: number;
            },
            {
                n?: string;
                r?: number;
                k?: number;
            }
        ];
    }>;
    standing?: {
        page?: number;
        players?: Array<ArenaPlayerPerformance>;
    };
    featured?: {
        id?: string;
        fen?: string;
        orientation?: string;
        color?: string;
        lastMove?: string;
        white?: {
            name?: string;
            id?: string;
            rank?: number;
            rating?: number;
        };
        black?: {
            name?: string;
            id?: string;
            rank?: number;
            rating?: number;
        };
        c?: {
            /**
             * white's clock in seconds
             */
            white?: number;
            /**
             * black's clock in seconds
             */
            black?: number;
        };
    };
    podium?: Array<ArenaPlayerPerformance>;
    stats: {
        games: number;
        moves: number;
        whiteWins: number;
        blackWins: number;
        draws: number;
        berserks: number;
        averageRating: number;
    };
};

export type _Error = {
    /**
     * The cause of the error.
     */
    error?: string;
};

export type ArenaTournamentPlayed = {
    tournament?: ArenaTournament;
    player?: {
        games: number;
        score: number;
        rank: number;
        performance?: number;
    };
};

/**
 * Custom initial position (in FEN). Variant must be standard and the game cannot be rated.
 */
export type SwissFromPositionFen = string;

/**
 * The current state of the swiss tournament
 */
export type SwissStatus = 'created' | 'started' | 'finished';

export type SwissTournament = {
    id: string;
    createdBy: string;
    startsAt: string;
    name: string;
    clock: {
        limit: number;
        increment: number;
    };
    variant: string;
    round: number;
    nbRounds: number;
    nbPlayers: number;
    nbOngoing: number;
    status: SwissStatus;
    stats: {
        games: number;
        whiteWins: number;
        blackWins: number;
        draws: number;
        byes: number;
        absences: number;
        averageRating: number;
    };
    rated: boolean;
    verdicts: Verdicts;
};

export type SwissUnauthorisedEdit = {
    error?: string;
};

export type StudyPgn = unknown;

export type StudyImportPgnChapters = {
    chapters?: Array<{
        /**
         * The chapter ID
         */
        id?: string;
        /**
         * The chapter name
         */
        name?: string;
        players?: [
            {
                /**
                 * The player name
                 */
                name?: string | null;
                /**
                 * The player rating
                 */
                rating?: number;
            },
            {
                /**
                 * The player name
                 */
                name?: string | null;
                /**
                 * The player rating
                 */
                rating?: number;
            }
        ];
        /**
         * The chapter status
         */
        status?: string;
    }>;
};

export type StudyMetadata = {
    /**
     * The study ID
     */
    id?: string;
    /**
     * The study name
     */
    name?: string;
    /**
     * The study creation date
     */
    createdAt?: number;
    /**
     * The study last update date
     */
    updatedAt?: number;
};

export type BroadcastTour = {
    id: string;
    name: string;
    slug: string;
    createdAt: number;
    /**
     * Start and end dates of the tournament, as Unix timestamps in milliseconds
     */
    dates?: Array<number>;
    /**
     * Additional display information about the tournament
     */
    info?: {
        /**
         * Official website. External website URL
         */
        website?: string;
        /**
         * Featured players
         */
        players?: string;
        /**
         * Tournament location
         */
        location?: string;
        /**
         * Time control
         */
        tc?: string;
        /**
         * FIDE rating category
         */
        fideTc?: 'standard' | 'rapid' | 'blitz';
        /**
         * Timezone of the tournament. Example: `America/New_York`.
         * See [list of possible timezone identifiers](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for more.
         *
         */
        timeZone?: string;
        /**
         * Official standings website. External website URL
         */
        standings?: string;
        /**
         * Tournament format
         */
        format?: string;
    };
    /**
     * Used to designate featured tournaments on Lichess
     */
    tier?: number;
    image?: string;
    /**
     * Full tournament description in markdown format, or in HTML if the html=1 query parameter is set.
     */
    description?: string;
    leaderboard?: boolean;
    teamTable?: boolean;
    url: string;
};

export type BroadcastGroupTour = {
    name?: string;
    id?: string;
};

export type BroadcastGroup = {
    name?: string;
    tours?: Array<BroadcastGroupTour>;
};

export type BroadcastRoundInfo = {
    id: string;
    name: string;
    slug: string;
    createdAt: number;
    ongoing?: boolean;
    startsAt?: number;
    /**
     * The start date/time is unknown and the round will start automatically when the previous round completes
     */
    startsAfterPrevious?: boolean;
    finishedAt?: number;
    url: string;
    delay?: number;
};

export type BroadcastWithRounds = {
    tour: BroadcastTour;
    group?: BroadcastGroup;
    rounds: Array<BroadcastRoundInfo>;
};

export type BroadcastWithLastRound = {
    group?: string;
    tour?: BroadcastTour;
    round?: BroadcastRoundInfo;
};

export type BroadcastTop = {
    active?: Array<BroadcastWithLastRound>;
    past?: {
        currentPage?: number;
        maxPerPage?: number;
        currentPageResults?: Array<BroadcastWithLastRound>;
        previousPage?: number | null;
        nextPage?: number | null;
    };
};

export type BroadcastByUser = {
    tour: BroadcastTour;
    round: BroadcastRoundInfo;
};

export type BroadcastForm = {
    /**
     * Name of the broadcast tournament.
     *
     * Example: `Sinquefield Cup`
     *
     */
    name: string;
    /**
     * Tournament format.
     * Example: `"8-player round-robin" or "5-round Swiss"`
     *
     */
    'info.format'?: string;
    /**
     * Tournament Location
     *
     */
    'info.location'?: string;
    /**
     * Time control.
     * Example: `"Classical" or "Rapid" or "Rapid & Blitz"`
     *
     */
    'info.tc'?: string;
    /**
     * FIDE rating category. Which FIDE ratings to use
     *
     */
    'info.fideTc'?: 'standard' | 'rapid' | 'blitz';
    /**
     * Timezone of the tournament. Example: `America/New_York`.
     * See [list of possible timezone identifiers](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for more.
     *
     */
    'info.timeZone'?: string;
    /**
     * Mention up to 4 of the best players participating.
     *
     */
    'info.players'?: string;
    /**
     * Official website. External website URL
     *
     */
    'info.website'?: string;
    /**
     * Official Standings. External website URL, e.g. chess-results.com, info64.org
     *
     */
    'info.standings'?: string;
    /**
     * Optional long description of the broadcast. Markdown is supported.
     *
     */
    markdown?: string;
    /**
     * Show players scores based on game results
     *
     */
    showScores?: boolean;
    /**
     * Show player's rating diffs
     *
     */
    showRatingDiffs?: boolean;
    /**
     * Show a team leaderboard. Requires WhiteTeam and BlackTeam PGN tags.
     *
     */
    teamTable?: boolean;
    /**
     * Optional replace player names, ratings and titles.
     *
     * One line per player, formatted as such:
     *
     * ```txt
     * player name = FIDE ID
     * ```
     *
     * Example:
     *
     * ```txt
     * Magnus Carlsen = 1503014
     * ```
     *
     * Player names ignore case and punctuation, and match all possible combinations of 2 words: "Jorge Rick Vito" will match "Jorge Rick", "jorge vito", "Rick, Vito", etc.
     *
     * If the player is NM or WNM, you can:
     *
     * ```txt
     * Player Name = FIDE ID / Title
     * ```
     *
     * Alternatively, you may set tags manually, like so:
     *
     * ```txt
     * player name / rating / title / new name
     * ```
     *
     * All values are optional. Example:
     * ```txt
     * Magnus Carlsen / 2863 / GM
     * YouGotLittUp / 1890 / / Louis Litt
     * ```
     *
     */
    players?: string;
    /**
     * Optional: assign players to teams
     *
     * One line per player, formatted as such:
     * ```txt
     * Team name; Fide Id or Player name
     * ```
     *
     * Example:
     * ```txt
     * Team Cats ; 3408230
     * Team Dogs ; Scooby Doo
     * ```
     *
     * By default the PGN tags WhiteTeam and BlackTeam are used.
     *
     */
    teams?: string;
    /**
     * Optional, for Lichess admins only, used to feature on /broadcast.
     *
     * * `3` for Official: normal tier
     * * `4` for Official: high tier
     * * `5` for Official: best tier
     * * `-1` for Private
     *
     */
    tier?: 3 | 4 | 5 | -1;
};

export type BroadcastPlayerEntry = {
    name?: string;
    score?: number;
    played?: number;
    rating?: number;
    ratingDiff?: number;
    performance?: number;
    title?: string;
    fideId?: number;
    fed?: string;
};

/**
 * Name of the broadcast round.
 * Example: `Round 1`
 *
 */
export type BroadcastRoundFormName = string;

export type BroadcastRoundForm = ({
    name: BroadcastRoundFormName;
} | {
    name: BroadcastRoundFormName;
    /**
     * URL that Lichess will poll to get updates about the games. It must be publicly accessible from the Internet.
     *
     * Example:
     * ```txt
     * https://myserver.org/myevent/round-10/games.pgn
     * ```
     *
     */
    syncUrl: string;
    /**
     * Filter games by round number
     *
     * Optional, only keep games from the source that match a round number.
     * It uses the PGN **Round** tag. These would match round 3:
     * ```txt
     * [Round "3"]
     * [Round "3.1"]
     * ```
     * If you set a round number, then games without a **Round** tag are dropped.
     *
     * It only works if you chose `syncUrl` or `syncUrls` as the source.
     *
     */
    onlyRound?: number;
    /**
     * Select slices of the games
     *
     * Optional. Select games based on their position in the source.
     * ```txt
     * 1           only select the first board
     * 1-4         only select the first 4 boards
     * 1,2,3,4     same as above, first 4 boards
     * 11-15,21-25 boards 11 to 15, and boards 21 to 25
     * 2,3,7-9     boards 2, 3, 7, 8, and 9
     * ```
     * Slicing is done after filtering by round number.
     *
     * It only works if you chose `syncUrl` or `syncUrls` as the source.
     *
     */
    slices?: string;
} | {
    name: BroadcastRoundFormName;
    /**
     * URLs that Lichess will poll to get updates about the games, separated by newlines. They must be publicly accessible from the Internet.
     *
     * Example:
     * ```txt
     * https://myserver.org/myevent/round-10/game-1.pgn
     * https://myserver.org/myevent/round-10/game-2.pgn
     * ```
     *
     */
    syncUrls: string;
    /**
     * Filter games by round number
     *
     * Optional, only keep games from the source that match a round number.
     * It uses the PGN **Round** tag. These would match round 3:
     * ```txt
     * [Round "3"]
     * [Round "3.1"]
     * ```
     * If you set a round number, then games without a **Round** tag are dropped.
     *
     * It only works if you chose `syncUrl` or `syncUrls` as the source.
     *
     */
    onlyRound?: number;
    /**
     * Select slices of the games
     *
     * Optional. Select games based on their position in the source.
     * ```txt
     * 1           only select the first board
     * 1-4         only select the first 4 boards
     * 1,2,3,4     same as above, first 4 boards
     * 11-15,21-25 boards 11 to 15, and boards 21 to 25
     * 2,3,7-9     boards 2, 3, 7, 8, and 9
     * ```
     * Slicing is done after filtering by round number.
     *
     * It only works if you chose `syncUrl` or `syncUrls` as the source.
     *
     */
    slices?: string;
} | {
    name: BroadcastRoundFormName;
    /**
     * Lichess game IDs - Up to 64 Lichess game IDs, separated by spaces.
     *
     */
    syncIds: string;
} | {
    name: BroadcastRoundFormName;
    /**
     * Up to 100 Lichess usernames, separated by spaces
     *
     */
    syncUsers: string;
}) & {
    /**
     * Timestamp in milliseconds of broadcast round start. Leave empty to manually start the broadcast round.
     * Example: `1356998400070`
     *
     */
    startsAt?: number;
    /**
     * The start date is unknown, and the round will start automatically when the previous round completes.
     *
     */
    startsAfterPrevious?: boolean;
    /**
     * Delay in seconds for movements to appear on the broadcast. Leave it empty if you don't need it.
     * Example: `900` (15 min)
     *
     */
    delay?: number;
    /**
     * Lichess can usually detect the round status, but you can also set it manually if needed.
     *
     */
    status?: 'new' | 'started' | 'finished';
    /**
     * (Only for Admins) Waiting time for each poll.
     *
     */
    period?: number;
};

export type BroadcastRoundStudyInfo = {
    /**
     * Whether the currently authenticated user has permission to update the study
     */
    writeable?: boolean;
};

export type BroadcastRoundNew = {
    round: BroadcastRoundInfo;
    tour: BroadcastTour;
    study: BroadcastRoundStudyInfo;
};

export type BroadcastRoundGame = {
    id: string;
    name: string;
    fen?: string;
    players?: Array<{
        name?: string;
        title?: string;
        rating?: number;
        clock?: number;
        fed?: string;
    }>;
    lastMove?: string;
    thinkTime?: number;
    /**
     * The result of the game
     */
    status?: '*' | '1-0' | '0-1' | '½-½';
};

export type BroadcastRound = {
    round: BroadcastRoundInfo;
    tour: BroadcastTour;
    study: BroadcastRoundStudyInfo;
    games: Array<BroadcastRoundGame>;
    group?: BroadcastGroup;
};

export type BroadcastPgnPushTags = {
    [key: string]: string;
};

export type BroadcastPgnPush = {
    games: Array<{
        tags: BroadcastPgnPushTags;
        moves?: number;
        error?: string;
    }>;
};

export type BroadcastMyRound = {
    round: BroadcastRoundInfo;
    tour: BroadcastTour;
    study: BroadcastRoundStudyInfo;
};

export type FidePlayer = {
    id: number;
    name: string;
    title?: Title;
    federation: string;
    year?: number;
    inactive?: boolean;
    standard?: number;
    rapid?: number;
    blitz?: number;
};

export type Simul = {
    id: string;
    host: LightUser & {
        rating?: number;
        provisional?: boolean;
        gameId?: string;
        online?: boolean;
    };
    name: string;
    fullName: string;
    variants: Array<Variant>;
    isCreated: boolean;
    isFinished: boolean;
    isRunning: boolean;
    text?: string;
    estimatedStartAt?: number;
    startedAt?: number;
    finishedAt?: number;
    nbApplicants: number;
    nbPairings: number;
};

export type Team = {
    id: string;
    name: string;
    description?: string;
    flair?: Flair;
    leaders?: Array<LightUser>;
    nbMembers?: number;
    open?: boolean;
    joined?: boolean;
    requested?: boolean;
};

export type TeamPaginatorJson = {
    currentPage?: number;
    maxPerPage?: number;
    currentPageResults?: Array<Team>;
    nbResults?: number;
    previousPage?: number | null;
    nextPage?: number | null;
    nbPages?: number;
};

/**
 * The current state of the arena tournament
 */
export type ArenaStatusName = 'created' | 'started' | 'finished';

export type TeamRequest = {
    teamId?: string;
    userId?: string;
    date?: number;
    message?: string;
};

export type TeamRequestWithUser = {
    request?: TeamRequest;
    user?: User;
};

export type Crosstable = unknown;

export type LightUserOnline = LightUser & {
    online?: boolean;
};

export type UserNote = {
    from?: LightUser;
    to?: LightUser;
    text?: string;
    date?: number;
};

export type GameEventInfo = {
    id?: string;
    source?: GameSource;
    status?: {
        id?: 10 | 20 | 25 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 60;
        name?: GameStatus;
    };
    winner?: 'white' | 'black';
    compat?: {
        bot?: boolean;
        board?: boolean;
    };
};

export type GameStartEvent = {
    type?: 'gameStart';
    game?: GameEventInfo;
};

export type GameFinishEvent = {
    type?: 'gameFinish';
    game?: GameEventInfo;
};

export type ChallengeUser = LightUser & {
    rating?: number;
    provisional?: boolean;
    online?: boolean;
    lag?: number;
};

export type ChallengeJson = {
    id: string;
    url: string;
    status: 'created' | 'offline' | 'canceled' | 'declined' | 'accepted';
    challenger: ChallengeUser;
    destUser: ChallengeUser | null;
    variant: Variant;
    rated: boolean;
    speed: Speed;
    timeControl: {
        type?: string;
        limit?: number;
        increment?: number;
        show?: string;
    } | {
        type?: string;
        daysPerTurn?: number;
    } | {
        type?: string;
    };
    color: 'white' | 'black' | 'random';
    finalColor?: 'white' | 'black';
    perf: {
        icon?: string;
        name?: string;
    };
    direction?: 'in' | 'out';
    initialFen?: string;
    /**
     * Human readable, possibly translated reason why the challenge was declined.
     */
    declineReason?: string;
    /**
     * Untranslated, computer-matchable reason why the challenge was declined.
     */
    declineReasonKey?: string;
};

export type ChallengeEvent = {
    type?: 'challenge';
    challenge?: ChallengeJson;
};

export type ChallengeCanceledEvent = {
    type?: 'challengeCanceled';
    challenge?: ChallengeJson;
};

export type ChallengeCanceledJson = {
    id?: string;
};

export type ChallengeDeclinedEvent = {
    type?: 'challengeDeclined';
    challenge?: ChallengeCanceledJson;
};

export type GameEventPlayer = {
    aiLevel?: number;
    id?: string;
    name?: string;
    title?: string | null;
    rating?: number;
    provisional?: boolean;
};

export type GameStateEvent = {
    type: 'gameState';
    /**
     * Current moves in UCI format
     */
    moves: string;
    /**
     * Integer of milliseconds White has left on the clock
     */
    wtime: number;
    /**
     * Integer of milliseconds Black has left on the clock
     */
    btime: number;
    /**
     * Integer of White Fisher increment.
     */
    winc: number;
    /**
     * Integer of Black Fisher increment.
     */
    binc: number;
    status: GameStatus;
    /**
     * Color of the winner, if any
     */
    winner?: string;
    /**
     * true if white is offering draw, else omitted
     */
    wdraw?: boolean;
    /**
     * true if black is offering draw, else omitted
     */
    bdraw?: boolean;
    /**
     * true if white is proposing takeback, else omitted
     */
    wtakeback?: boolean;
    /**
     * true if black is proposing takeback, else omitted
     */
    btakeback?: boolean;
};

export type GameFullEvent = {
    type: 'gameFull';
    id: string;
    variant: Variant;
    clock: Clock | null;
    speed: Speed;
    perf: {
        /**
         * Translated perf name (e.g. "Classical" or "Blitz")
         */
        name?: string;
    };
    rated: boolean;
    createdAt: number;
    white: GameEventPlayer;
    black: GameEventPlayer;
    initialFen: string;
    state: GameStateEvent;
    tournamentId?: string;
};

export type ChatLineEvent = {
    type: 'chatLine';
    room: 'player' | 'spectator';
    username: string;
    text: string;
};

export type OpponentGone = {
    type: 'opponentGone';
    gone: boolean;
    claimWinInSeconds?: number;
};

export type NotFound = {
    error?: string;
};

export type GameChat = unknown;

export type ChallengeOpenJson = {
    id: string;
    url: string;
    status: 'created' | 'offline' | 'canceled' | 'declined' | 'accepted';
    challenger: null;
    destUser: null;
    variant: Variant;
    rated: boolean;
    speed: Speed;
    timeControl: {
        type?: string;
        limit?: number;
        increment?: number;
        show?: string;
    } | {
        type?: string;
        daysPerTurn?: number;
    } | {
        type?: string;
    };
    color: 'white' | 'black' | 'random';
    finalColor?: 'white' | 'black';
    perf: {
        icon?: string;
        name?: string;
    };
    initialFen?: string;
    urlWhite: string;
    urlBlack: string;
    open: {
        /**
         * An optional array of two user ids. If set, only these users will be allowed to join the game. The first username gets the white pieces.
         */
        userIds?: Array<string>;
    };
};

export type BulkPairing = unknown;

export type CloudEval = {
    depth: number;
    fen: string;
    knodes: number;
    pvs: Array<{
        /**
         * Variation in UCI notation
         */
        moves: string;
    } & ({
        /**
         * Evaluation in centi-pawns, from White's point of view
         */
        cp: number;
    } | {
        /**
         * Evaluation in moves to mate, from White's point of view
         */
        mate: number;
    })>;
};

export type UciVariant = 'chess' | 'crazyhouse' | 'antichess' | 'atomic' | 'horde' | 'kingofthehill' | 'racingkings' | '3check';

export type ExternalEngine = {
    /**
     * Unique engine registration ID.
     */
    id: string;
    /**
     * Display name of the engine.
     */
    name: string;
    /**
     * A secret token that can be used to
     * [*request* analysis](#tag/External-engine/operation/apiExternalEngineAnalyse)
     * from this external engine.
     *
     */
    clientSecret: string;
    /**
     * The user this engine has been registered for.
     */
    userId: string;
    /**
     * Maximum number of available threads.
     */
    maxThreads: number;
    /**
     * Maximum available hash table size, in MiB.
     */
    maxHash: number;
    /**
     * List of supported chess variants.
     */
    variants: Array<UciVariant>;
    /**
     * Arbitrary data that the engine provider can use for identification
     * or bookkeeping.
     *
     * Users can read this information, but updating it requires knowing
     * or changing the `providerSecret`.
     *
     */
    providerData?: string;
};

export type ExternalEngineRegistration = {
    /**
     * Display name of the engine.
     */
    name: string;
    /**
     * Maximum number of available threads.
     */
    maxThreads: number;
    /**
     * Maximum available hash table size, in MiB.
     */
    maxHash: number;
    /**
     * Optional list of supported chess variants.
     */
    variants?: Array<UciVariant>;
    /**
     * A random token that can be used to
     * [wait for analysis requests](#tag/External-engine/operation/apiExternalEngineAcquire)
     * and provide analysis.
     *
     * The engine provider should securely generate a random string.
     *
     * The token will not be readable again, even by the user.
     *
     * The analysis provider can register multiple engines with the same
     * token, even for different users, and wait for analysis requests
     * from any of them. In this case, the request must not be made via
     * CORS, so that the token is not revealed to any of the users.
     *
     */
    providerSecret: string;
    /**
     * Arbitrary data that the engine provider can use for identification
     * or bookkeeping.
     *
     * Users can read this information, but updating it requires knowing
     * or changing the `providerSecret`.
     *
     */
    providerData?: string;
};

export type ExternalEngineWork = {
    /**
     * Arbitary string that identifies the analysis session.
     * Providers may wish to clear the hash table between sessions.
     *
     */
    sessionId: string;
    /**
     * Number of threads to use for analysis.
     */
    threads: number;
    /**
     * Hash table size to use for analysis, in MiB.
     */
    hash: number;
    /**
     * Requested number of principal variations.
     */
    multiPv: number;
    variant: UciVariant;
    /**
     * Initial position of the game.
     */
    initialFen: string;
    /**
     * List of moves played from the initial position, in UCI notation.
     */
    moves: Array<string>;
    /**
     * Amount of time to analyse the position, in milliseconds.
     */
    movetime?: number;
    /**
     * Analysis target depth
     */
    depth?: number;
    /**
     * Number of nodes to analyse in the position
     */
    nodes?: number;
};

export type OAuthError = {
    /**
     * The cause of the error.
     */
    error?: string;
    /**
     * The reason why the request was rejected.
     */
    error_description?: string;
};

export type OpeningExplorerOpening = {
    eco: string;
    name: string;
};

export type OpeningExplorerGamePlayer = {
    name: string;
    rating: number;
};

export type OpeningExplorerMastersGame = {
    id: string;
    winner: 'white' | 'black';
    white: OpeningExplorerGamePlayer;
    black: OpeningExplorerGamePlayer;
    year: number;
    month?: string;
};

export type OpeningExplorerMasters = {
    opening: OpeningExplorerOpening | null;
    white: number;
    draws: number;
    black: number;
    moves: Array<{
        uci: string;
        san: string;
        averageRating: number;
        white: number;
        draws: number;
        black: number;
        game: OpeningExplorerMastersGame | null;
        opening: OpeningExplorerOpening | null;
    }>;
    topGames: Array<{
        uci: string;
    } & OpeningExplorerMastersGame>;
};

export type OpeningExplorerLichessGame = {
    id: string;
    winner: 'white' | 'black';
    speed: Speed;
    white: OpeningExplorerGamePlayer;
    black: OpeningExplorerGamePlayer;
    year: number;
    month: string;
};

export type OpeningExplorerLichess = {
    opening: OpeningExplorerOpening | null;
    white: number;
    draws: number;
    black: number;
    moves: Array<{
        uci: string;
        san: string;
        averageRating: number;
        white: number;
        draws: number;
        black: number;
        game: OpeningExplorerLichessGame | null;
        opening: OpeningExplorerOpening | null;
    }>;
    topGames: Array<{
        uci: string;
    } & OpeningExplorerLichessGame>;
    recentGames: Array<{
        uci: string;
    } & OpeningExplorerLichessGame>;
    history?: Array<{
        month: string;
        white: number;
        draws: number;
        black: number;
    }>;
};

export type OpeningExplorerPlayerGame = {
    id: string;
    winner: 'white' | 'black';
    speed: Speed;
    mode: 'rated' | 'casual';
    white: OpeningExplorerGamePlayer;
    black: OpeningExplorerGamePlayer;
    year: number;
    month: string;
};

export type OpeningExplorerPlayer = {
    opening: OpeningExplorerOpening | null;
    queuePosition: number;
    white: number;
    draws: number;
    black: number;
    moves: Array<{
        uci: string;
        san: string;
        averageOpponentRating: number;
        performance: number;
        white: number;
        draws: number;
        black: number;
        game: OpeningExplorerPlayerGame | null;
        opening: OpeningExplorerOpening | null;
    }>;
    recentGames: Array<{
        uci: string;
    } & OpeningExplorerPlayerGame>;
};

export type MasterGamePgn = unknown;

export type Move = {
    uci?: string;
    san?: string;
    category?: 'loss' | 'unknown' | 'syzygy-loss' | 'maybe-loss' | 'blessed-loss' | 'draw' | 'cursed-win' | 'maybe-win' | 'syzygy-win' | 'win';
    /**
     * DTZ50'' with rounding or null if unknown
     */
    dtz?: null | number;
    /**
     * DTZ50'' (only if guaranteed to be not rounded) or null if unknown
     *
     */
    precise_dtz?: null | number;
    /**
     * Depth to Conversion (experimental)
     */
    dtc?: null | number;
    /**
     * Depth To Mate (only for Standard positions with not more than 5 pieces)
     */
    dtm?: null | number;
    /**
     * Depth To Win (only for Antichess positions with not more than 4 pieces)
     */
    dtw?: null | number;
    zeroing?: boolean;
    checkmate?: boolean;
    stalemate?: boolean;
    variant_win?: boolean;
    variant_loss?: boolean;
    insufficient_material?: boolean;
};

export type TablebaseJson = {
    /**
     * `cursed-win` and `blessed-loss` means the 50-move rule prevents
     * the decisive result.
     *
     * `syzygy-win` and `syzygy-loss` means exact result is unknown due to
     * [DTZ rounding](https://syzygy-tables.info/metrics#dtz), i.e., the
     * win or loss could also be prevented by the 50-move rule if
     * the user has deviated from the tablebase recommendation since the
     * last pawn move or capture.
     *
     * `maybe-win` and `maybe-loss` means the result with regard to the
     * 50-move rule is unknown because the DTC tablebase does not
     * guarantee to reach a zeroing move as soon as possible.
     *
     */
    category?: 'win' | 'unknown' | 'syzygy-win' | 'maybe-win' | 'cursed-win' | 'draw' | 'blessed-loss' | 'maybe-loss' | 'syzygy-loss' | 'loss';
    /**
     * [DTZ50'' with rounding](https://syzygy-tables.info/metrics#dtz) or null if unknown
     *
     */
    dtz?: null | number;
    /**
     * DTZ50'' (only if guaranteed to be not rounded) or null if unknown
     *
     */
    precise_dtz?: null | number;
    /**
     * Depth to Conversion (experimental)
     */
    dtc?: null | number;
    /**
     * Depth To Mate (only for Standard positions with not more than 5 pieces)
     */
    dtm?: null | number;
    /**
     * Depth To Win (only for Antichess positions with not more than 4 pieces)
     */
    dtw?: null | number;
    checkmate?: boolean;
    stalemate?: boolean;
    /**
     * Only in chess variants
     */
    variant_win?: boolean;
    /**
     * Only in chess variants
     */
    variant_loss?: boolean;
    insufficient_material?: boolean;
    /**
     * Information about legal moves, best first
     */
    moves?: Array<Move>;
};

export type ApiUsersStatusData = {
    body?: never;
    path?: never;
    query: {
        /**
         * User IDs separated by commas. Up to 100 IDs.
         */
        ids: string;
        /**
         * Also return the network signal of the player, when available.
         * It ranges from 1 (poor connection, lag > 500ms) to 4 (great connection, lag < 150ms)
         * Defaults to `false` to preserve server resources.
         *
         */
        withSignal?: boolean;
        /**
         * Also return the ID of the game being played, if any, for each player, in a `playingId` field.
         * Defaults to `false` to preserve server resources.
         *
         */
        withGameIds?: boolean;
        /**
         * Also return the id, time control and variant of the game being played, if any, for each player, in a `playing` field.
         * Defaults to `false` to preserve server resources. Disables `withGameIds`.
         *
         */
        withGameMetas?: boolean;
    };
    url: '/api/users/status';
};

export type ApiUsersStatusResponses = {
    /**
     * The list of users and their respective statuses.
     */
    200: Array<{
        id: string;
        name: string;
        title?: string;
        online?: boolean;
        playing?: boolean;
        streaming?: boolean;
        patron?: boolean;
    }>;
};

export type ApiUsersStatusResponse = ApiUsersStatusResponses[keyof ApiUsersStatusResponses];

export type PlayerData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/player';
};

export type PlayerResponses = {
    /**
     * The list of variants with their respective top players.
     */
    200: Top10S;
};

export type PlayerResponse = PlayerResponses[keyof PlayerResponses];

export type PlayerTopNbPerfTypeData = {
    body?: never;
    path: {
        /**
         * How many users to fetch
         */
        nb: number;
        /**
         * The speed or variant
         */
        perfType: 'ultraBullet' | 'bullet' | 'blitz' | 'rapid' | 'classical' | 'chess960' | 'crazyhouse' | 'antichess' | 'atomic' | 'horde' | 'kingOfTheHill' | 'racingKings' | 'threeCheck';
    };
    query?: never;
    url: '/api/player/top/{nb}/{perfType}';
};

export type PlayerTopNbPerfTypeResponses = {
    /**
     * The list of top players for the variant.
     */
    200: Leaderboard;
};

export type PlayerTopNbPerfTypeResponse = PlayerTopNbPerfTypeResponses[keyof PlayerTopNbPerfTypeResponses];

export type ApiUserData = {
    body?: never;
    path: {
        username: string;
    };
    query?: {
        /**
         * Include user trophies
         */
        trophies?: boolean;
    };
    url: '/api/user/{username}';
};

export type ApiUserResponses = {
    /**
     * The information of the user.
     */
    200: UserExtended;
};

export type ApiUserResponse = ApiUserResponses[keyof ApiUserResponses];

export type ApiUserRatingHistoryData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/user/{username}/rating-history';
};

export type ApiUserRatingHistoryResponses = {
    /**
     * The rating history of the user.
     */
    200: RatingHistory;
};

export type ApiUserRatingHistoryResponse = ApiUserRatingHistoryResponses[keyof ApiUserRatingHistoryResponses];

export type ApiUserPerfData = {
    body?: never;
    path: {
        username: string;
        perf: PerfType;
    };
    query?: never;
    url: '/api/user/{username}/perf/{perf}';
};

export type ApiUserPerfResponses = {
    /**
     * The performance statistics of the user
     */
    200: PerfStat;
};

export type ApiUserPerfResponse = ApiUserPerfResponses[keyof ApiUserPerfResponses];

export type ApiUserActivityData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/user/{username}/activity';
};

export type ApiUserActivityResponses = {
    /**
     * The activity feed of the user.
     */
    200: UserActivity;
};

export type ApiUserActivityResponse = ApiUserActivityResponses[keyof ApiUserActivityResponses];

export type ApiPuzzleDailyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/puzzle/daily';
};

export type ApiPuzzleDailyResponses = {
    /**
     * The daily puzzle.
     */
    200: PuzzleAndGame;
};

export type ApiPuzzleDailyResponse = ApiPuzzleDailyResponses[keyof ApiPuzzleDailyResponses];

export type ApiPuzzleIdData = {
    body?: never;
    path: {
        /**
         * The puzzle ID
         */
        id: string;
    };
    query?: never;
    url: '/api/puzzle/{id}';
};

export type ApiPuzzleIdResponses = {
    /**
     * The requested puzzle.
     */
    200: PuzzleAndGame;
};

export type ApiPuzzleIdResponse = ApiPuzzleIdResponses[keyof ApiPuzzleIdResponses];

export type ApiPuzzleNextData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The theme or opening to filter puzzles with.
         *
         * Available themes are listed in [the lichess source code](https://github.com/ornicar/lila/blob/master/translation/source/puzzleTheme.xml).
         *
         */
        angle?: string;
        /**
         * The desired puzzle difficulty, relative to the authenticated user puzzle rating, or 1500 if anonymous.
         */
        difficulty?: 'easiest' | 'easier' | 'normal' | 'harder' | 'hardest';
    };
    url: '/api/puzzle/next';
};

export type ApiPuzzleNextResponses = {
    /**
     * The requested puzzle.
     */
    200: PuzzleAndGame;
};

export type ApiPuzzleNextResponse = ApiPuzzleNextResponses[keyof ApiPuzzleNextResponses];

export type ApiPuzzleActivityData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * How many entries to download. Leave empty to download all activity.
         */
        max?: number;
        /**
         * Download entries before this timestamp. Defaults to now. Use `before` and `max` for pagination.
         */
        before?: number;
    };
    url: '/api/puzzle/activity';
};

export type ApiPuzzleActivityResponses = {
    /**
     * The puzzle activity of the logged in user.
     */
    200: PuzzleActivity;
};

export type ApiPuzzleActivityResponse = ApiPuzzleActivityResponses[keyof ApiPuzzleActivityResponses];

export type ApiPuzzleReplayData = {
    body?: never;
    path: {
        /**
         * How many days to look back when aggregating puzzle results. 30 is sensible.
         */
        days: number;
        /**
         * The theme or opening to filter puzzles with.
         */
        theme: string;
    };
    query?: never;
    url: '/api/puzzle/replay/{days}/{theme}';
};

export type ApiPuzzleReplayErrors = {
    /**
     * No puzzles to replay were found
     */
    404: {
        error?: string;
    };
};

export type ApiPuzzleReplayError = ApiPuzzleReplayErrors[keyof ApiPuzzleReplayErrors];

export type ApiPuzzleReplayResponses = {
    /**
     * The requested puzzles to replay.
     */
    200: PuzzleReplay;
};

export type ApiPuzzleReplayResponse = ApiPuzzleReplayResponses[keyof ApiPuzzleReplayResponses];

export type ApiPuzzleDashboardData = {
    body?: never;
    path: {
        /**
         * How many days to look back when aggregating puzzle results. 30 is sensible.
         */
        days: number;
    };
    query?: never;
    url: '/api/puzzle/dashboard/{days}';
};

export type ApiPuzzleDashboardResponses = {
    /**
     * The puzzle dashboard of the logged in user.
     */
    200: PuzzleDashboard;
};

export type ApiPuzzleDashboardResponse = ApiPuzzleDashboardResponses[keyof ApiPuzzleDashboardResponses];

export type ApiStormDashboardData = {
    body?: never;
    path: {
        /**
         * Username of the player
         */
        username: string;
    };
    query?: {
        /**
         * How many days of history to return
         */
        days?: number;
    };
    url: '/api/storm/dashboard/{username}';
};

export type ApiStormDashboardResponses = {
    /**
     * The storm dashboard of a player.
     */
    200: PuzzleStormDashboard;
};

export type ApiStormDashboardResponse = ApiStormDashboardResponses[keyof ApiStormDashboardResponses];

export type RacerPostData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/racer';
};

export type RacerPostResponses = {
    /**
     * The new puzzle race.
     */
    200: PuzzleRacer;
};

export type RacerPostResponse = RacerPostResponses[keyof RacerPostResponses];

export type ApiUsersData = {
    /**
     * User IDs separated by commas.
     */
    body: string;
    path?: never;
    query?: never;
    url: '/api/users';
};

export type ApiUsersResponses = {
    /**
     * The list of users.
     */
    200: Array<User>;
};

export type ApiUsersResponse = ApiUsersResponses[keyof ApiUsersResponses];

export type AccountMeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/account';
};

export type AccountMeResponses = {
    /**
     * The public information about the logged in user.
     */
    200: UserExtended;
};

export type AccountMeResponse = AccountMeResponses[keyof AccountMeResponses];

export type AccountEmailData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/account/email';
};

export type AccountEmailResponses = {
    /**
     * The email address of the logged in user.
     */
    200: {
        email?: string;
    };
};

export type AccountEmailResponse = AccountEmailResponses[keyof AccountEmailResponses];

export type AccountData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/account/preferences';
};

export type AccountResponses = {
    /**
     * The preferences of the logged in user.
     */
    200: {
        prefs?: UserPreferences;
        language?: string;
    };
};

export type AccountResponse = AccountResponses[keyof AccountResponses];

export type AccountKidData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/account/kid';
};

export type AccountKidResponses = {
    /**
     * The kid mode status of the logged in user.
     */
    200: {
        kid?: boolean;
    };
};

export type AccountKidResponse = AccountKidResponses[keyof AccountKidResponses];

export type AccountKidPostData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Kid mode status
         */
        v: boolean;
    };
    url: '/api/account/kid';
};

export type AccountKidPostResponses = {
    /**
     * The kid mode status was set successfully for the logged in user.
     */
    200: Ok;
};

export type AccountKidPostResponse = AccountKidPostResponses[keyof AccountKidPostResponses];

export type TimelineData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Show events since this timestamp.
         */
        since?: number;
        /**
         * Max number of events to fetch.
         */
        nb?: number;
    };
    url: '/api/timeline';
};

export type TimelineResponses = {
    /**
     * The events in the timeline of the logged in user.
     */
    200: Timeline;
};

export type TimelineResponse = TimelineResponses[keyof TimelineResponses];

export type GamePgnData = {
    body?: never;
    path: {
        /**
         * The game ID
         */
        gameId: string;
    };
    query?: {
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
        /**
         * Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         * Example: `5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *
         */
        literate?: boolean;
        /**
         * Add a `bookmarked: true` JSON field when the logged in user has bookmarked the game.
         * The response type must be set to `application/x-ndjson` by the request `Accept` header.
         *
         */
        withBookmarked?: boolean;
        /**
         * URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN.
         * Example: <https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt>
         *
         */
        players?: string;
    };
    url: '/game/export/{gameId}';
};

export type GamePgnResponses = {
    /**
     * The game representation.
     */
    200: GamePgn;
};

export type GamePgnResponse = GamePgnResponses[keyof GamePgnResponses];

export type ApiUserCurrentGameData = {
    body?: never;
    path: {
        username: string;
    };
    query?: {
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
        /**
         * Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         * Example: `5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *
         */
        literate?: boolean;
        /**
         * URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN.
         * Example: <https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt>
         *
         */
        players?: string;
    };
    url: '/api/user/{username}/current-game';
};

export type ApiUserCurrentGameResponses = {
    /**
     * The ongoing (or last) game of a user.
     */
    200: GamePgn;
};

export type ApiUserCurrentGameResponse = ApiUserCurrentGameResponses[keyof ApiUserCurrentGameResponses];

export type ApiGamesUserData = {
    body?: never;
    path: {
        /**
         * The user name.
         */
        username: string;
    };
    query?: {
        /**
         * Download games played since this timestamp. Defaults to account creation date.
         */
        since?: number;
        /**
         * Download games played until this timestamp. Defaults to now.
         */
        until?: number;
        /**
         * How many games to download. Leave empty to download all games.
         */
        max?: number;
        /**
         * [Filter] Only games played against this opponent
         */
        vs?: string;
        /**
         * [Filter] Only rated (`true`) or casual (`false`) games
         */
        rated?: boolean;
        /**
         * [Filter] Only games in these speeds or variants.
         * Multiple perf types can be specified, separated by a comma.
         * Example: blitz,rapid,classical
         *
         */
        perfType?: PerfType & unknown;
        /**
         * [Filter] Only games played as this color.
         */
        color?: 'white' | 'black';
        /**
         * [Filter] Only games with or without a computer analysis available
         */
        analysed?: boolean;
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field. The response type must be set to `application/x-ndjson` by the request `Accept` header.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
        /**
         * Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
         */
        ongoing?: boolean;
        /**
         * Include finished games. Set to `false` to only get ongoing games.
         */
        finished?: boolean;
        /**
         * Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         * Example: `5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *
         */
        literate?: boolean;
        /**
         * Include the FEN notation of the last position of the game.
         * The response type must be set to `application/x-ndjson` by the request `Accept` header.
         *
         */
        lastFen?: boolean;
        /**
         * Add a `bookmarked: true` JSON field when the logged in user has bookmarked the game.
         * The response type must be set to `application/x-ndjson` by the request `Accept` header.
         *
         */
        withBookmarked?: boolean;
        /**
         * URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN.
         * Example: <https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt>
         *
         */
        players?: string;
        /**
         * Sort order of the games.
         */
        sort?: 'dateAsc' | 'dateDesc';
    };
    url: '/api/games/user/{username}';
};

export type ApiGamesUserResponses = {
    /**
     * The games of the user.
     */
    200: GamePgn;
};

export type ApiGamesUserResponse = ApiGamesUserResponses[keyof ApiGamesUserResponses];

export type GamesExportIdsData = {
    /**
     * Game IDs separated by commas. Up to 300.
     */
    body: string;
    path?: never;
    query?: {
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
        /**
         * Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         * Example: `5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *
         */
        literate?: boolean;
        /**
         * URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN.
         * Example: <https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt>
         *
         */
        players?: string;
    };
    url: '/api/games/export/_ids';
};

export type GamesExportIdsResponses = {
    /**
     * The representation of the games.
     */
    200: GamePgn;
};

export type GamesExportIdsResponse = GamesExportIdsResponses[keyof GamesExportIdsResponses];

export type GamesByUsersData = {
    /**
     * Up to 300 user IDs separated by commas.
     * Example: `thibault,maia1,maia5`
     *
     */
    body: string;
    path?: never;
    query?: {
        /**
         * Include the already started games at the beginning of the stream.
         */
        withCurrentGames?: boolean;
    };
    url: '/api/stream/games-by-users';
};

export type GamesByUsersResponses = {
    /**
     * The stream of the games played between the users.
     */
    200: GameStream;
};

export type GamesByUsersResponse = GamesByUsersResponses[keyof GamesByUsersResponses];

export type GamesByIdsData = {
    /**
     * Up to 500 or 1000 game IDs separated by commas.
     * Example: `gameId01,gameId02,gameId03`
     *
     */
    body: string;
    path: {
        /**
         * Arbitrary stream ID that you can later use to add game IDs to the stream.
         */
        streamId: string;
    };
    query?: never;
    url: '/api/stream/games/{streamId}';
};

export type GamesByIdsResponses = {
    /**
     * The stream of the games matching the requested IDs.
     */
    200: GameStream;
};

export type GamesByIdsResponse = GamesByIdsResponses[keyof GamesByIdsResponses];

export type GamesByIdsAddData = {
    /**
     * Up to 500 or 1000 game IDs separated by commas.
     * Example: `gameId04,gameId05,gameId06`
     *
     */
    body: string;
    path: {
        /**
         * The stream ID you used to [create the stream](#operation/gamesByIds).
         */
        streamId: string;
    };
    query?: never;
    url: '/api/stream/games/{streamId}/add';
};

export type GamesByIdsAddResponses = {
    /**
     * The game IDs have been added to the stream.
     */
    200: Ok;
};

export type GamesByIdsAddResponse = GamesByIdsAddResponses[keyof GamesByIdsAddResponses];

export type ApiAccountPlayingData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Max number of games to fetch
         */
        nb?: number;
    };
    url: '/api/account/playing';
};

export type ApiAccountPlayingResponses = {
    /**
     * The ongoing games of the logged in user.
     */
    200: {
        nowPlaying: Array<{
            fullId: string;
            gameId: string;
            fen: string;
            color: 'white' | 'black';
            lastMove: string;
            source: GameSource;
            status?: GameStatus;
            variant: Variant;
            speed: Speed;
            perf: PerfType;
            rated: boolean;
            hasMoved: boolean;
            opponent: {
                id: string;
                username: string;
                rating?: number;
                ratingDiff?: number;
                ai?: number;
            };
            isMyTurn: boolean;
            secondsLeft: number;
            tournamentId?: string;
            swissId?: string;
            winner?: 'white' | 'black';
            ratingDiff?: number;
        }>;
    };
};

export type ApiAccountPlayingResponse = ApiAccountPlayingResponses[keyof ApiAccountPlayingResponses];

export type StreamGameData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/stream/game/{id}';
};

export type StreamGameResponses = {
    /**
     * The stream of the game moves.
     */
    200: MoveStream;
};

export type StreamGameResponse = StreamGameResponses[keyof StreamGameResponses];

export type GameImportData = {
    /**
     * A single game to import
     */
    body: {
        /**
         * The PGN. It can contain only one game. Most standard tags are supported.
         */
        pgn?: string;
    };
    path?: never;
    query?: never;
    url: '/api/import';
};

export type GameImportResponses = {
    /**
     * The game was successfully imported.
     */
    200: {
        /**
         * The game ID
         */
        id?: string;
        /**
         * The game URL
         */
        url?: string;
    };
};

export type GameImportResponse = GameImportResponses[keyof GameImportResponses];

export type ApiImportedGamesUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/games/export/imports';
};

export type ApiImportedGamesUserResponses = {
    /**
     * Imported games in PGN format
     */
    200: GamePgn;
};

export type ApiImportedGamesUserResponse = ApiImportedGamesUserResponses[keyof ApiImportedGamesUserResponses];

export type ApiExportBookmarksData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Download games bookmarked since this timestamp. Defaults to account creation date.
         */
        since?: number;
        /**
         * Download games bookmarked until this timestamp. Defaults to now.
         */
        until?: number;
        /**
         * How many bookmarked games to download. Leave empty to download all bookmarked games.
         */
        max?: number;
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field. The response type must be set to `application/x-ndjson` by the request `Accept` header.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
        /**
         * Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         * Example: `5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *
         */
        literate?: boolean;
        /**
         * Include the FEN notation of the last position of the game.
         * The response type must be set to `application/x-ndjson` by the request `Accept` header.
         *
         */
        lastFen?: boolean;
        /**
         * Sort order of the bookmarks.
         */
        sort?: 'dateAsc' | 'dateDesc';
    };
    url: '/api/games/export/bookmarks';
};

export type ApiExportBookmarksResponses = {
    /**
     * The bookmarked games of the user.
     */
    200: GamePgn;
};

export type ApiExportBookmarksResponse = ApiExportBookmarksResponses[keyof ApiExportBookmarksResponses];

export type TvChannelsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/tv/channels';
};

export type TvChannelsResponses = {
    /**
     * The list of games being played for each speed and variant.
     */
    200: {
        bot: TvGame;
        blitz: TvGame;
        racingKings: TvGame;
        ultraBullet: TvGame;
        bullet: TvGame;
        classical: TvGame;
        threeCheck: TvGame;
        antichess: TvGame;
        computer: TvGame;
        horde: TvGame;
        rapid: TvGame;
        atomic: TvGame;
        crazyhouse: TvGame;
        chess960: TvGame;
        kingOfTheHill: TvGame;
        best: TvGame;
    };
};

export type TvChannelsResponse = TvChannelsResponses[keyof TvChannelsResponses];

export type TvFeedData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/tv/feed';
};

export type TvFeedResponses = {
    /**
     * The stream of the current TV game.
     */
    200: TvFeed;
};

export type TvFeedResponse = TvFeedResponses[keyof TvFeedResponses];

export type TvChannelFeedData = {
    body?: never;
    path: {
        /**
         * The name of the channel in camel case.
         */
        channel: string;
    };
    query?: never;
    url: '/api/tv/{channel}/feed';
};

export type TvChannelFeedResponses = {
    /**
     * The stream of the current TV game of a TV channel.
     */
    200: TvFeed;
};

export type TvChannelFeedResponse = TvChannelFeedResponses[keyof TvChannelFeedResponses];

export type TvChannelGamesData = {
    body?: never;
    path: {
        /**
         * The name of the channel in camel case.
         */
        channel: string;
    };
    query?: {
        /**
         * Number of games to fetch.
         */
        nb?: number;
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
    };
    url: '/api/tv/{channel}';
};

export type TvChannelGamesResponses = {
    /**
     * The representation of the games.
     */
    200: GamePgn;
};

export type TvChannelGamesResponse = TvChannelGamesResponses[keyof TvChannelGamesResponses];

export type ApiTournamentData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/tournament';
};

export type ApiTournamentResponses = {
    /**
     * The list of current tournaments.
     */
    200: ArenaTournaments;
};

export type ApiTournamentResponse = ApiTournamentResponses[keyof ApiTournamentResponses];

export type ApiTournamentPostData = {
    /**
     * Parameters of the tournament
     */
    body: {
        /**
         * The tournament name. Leave empty to get a random Grandmaster name
         */
        name?: string;
        /**
         * Clock initial time in minutes
         */
        clockTime: 0 | 0.25 | 0.5 | 0.75 | 1 | 1.5 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 10 | 15 | 20 | 25 | 30 | 40 | 50 | 60;
        /**
         * Clock increment in seconds
         */
        clockIncrement: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 10 | 15 | 20 | 25 | 30 | 40 | 50 | 60;
        /**
         * How long the tournament lasts, in minutes
         */
        minutes: 20 | 25 | 30 | 35 | 40 | 45 | 50 | 55 | 60 | 70 | 80 | 90 | 100 | 110 | 120 | 150 | 180 | 210 | 240 | 270 | 300 | 330 | 360 | 420 | 480 | 540 | 600 | 720;
        /**
         * How long to wait before starting the tournament, from now, in minutes
         */
        waitMinutes?: 1 | 2 | 3 | 5 | 10 | 15 | 20 | 30 | 45 | 60;
        /**
         * Timestamp (in milliseconds) to start the tournament at a given date and time. Overrides the `waitMinutes` setting
         */
        startDate?: number;
        variant?: VariantKey;
        /**
         * Games are rated and impact players ratings
         */
        rated?: boolean;
        position?: FromPositionFen;
        /**
         * Whether the players can use berserk. Only allowed if clockIncrement <= clockTime * 2
         */
        berserkable?: boolean;
        /**
         * After 2 wins, consecutive wins grant 4 points instead of 2.
         */
        streakable?: boolean;
        /**
         * Whether the players can discuss in a chat
         */
        hasChat?: boolean;
        /**
         * Anything you want to tell players about the tournament
         */
        description?: string;
        /**
         * Make the tournament private, and restrict access with a password.
         * You can also [generate user-specific entry codes](https://github.com/lichess-org/api/tree/master/example/tournament-entry-code)
         * based on this password.
         *
         */
        password?: string;
        /**
         * Set the ID of a team you lead to create a team battle.
         * The other teams can be added using the [team battle edit endpoint](#operation/apiTournamentTeamBattlePost).
         *
         */
        teamBattleByTeam?: string;
        /**
         * Restrict entry to members of a team.
         * The teamId is the last part of a team URL, e.g. `https://lichess.org/team/coders` has teamId = `coders`.
         * Leave empty to let everyone join the tournament.
         * Do not use this to create team battles, use `teamBattleByTeam` instead.
         *
         */
        'conditions.teamMember.teamId'?: string;
        /**
         * Minimum rating to join. Leave empty to let everyone join the tournament.
         */
        'conditions.minRating.rating'?: 1000 | 1100 | 1200 | 1300 | 1400 | 1500 | 1600 | 1700 | 1800 | 1900 | 2000 | 2100 | 2200 | 2300 | 2400 | 2500 | 2600;
        /**
         * Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
         */
        'conditions.maxRating.rating'?: 2200 | 2100 | 2000 | 1900 | 1800 | 1700 | 1600 | 1500 | 1400 | 1300 | 1200 | 1100 | 1000 | 900 | 800;
        /**
         * Minimum number of rated games required to join.
         */
        'conditions.nbRatedGame.nb'?: 0 | 5 | 10 | 15 | 20 | 30 | 40 | 50 | 75 | 100 | 150 | 200;
        /**
         * Predefined list of usernames that are allowed to join, separated by commas.
         * If this list is non-empty, then usernames absent from this list will be forbidden to join.
         * Adding `%titled` to the list additionally allows any titled player to join.
         * Example: `thibault,german11,%titled`
         *
         */
        'conditions.allowList'?: string;
        /**
         * Whether bots are allowed to join the tournament.
         */
        'conditions.bots'?: boolean;
        /**
         * Minium account age in days required to join.
         */
        'conditions.accountAge'?: 1 | 3 | 7 | 14 | 30 | 60 | 90 | 180 | 365 | 730 | 1095;
    };
    path?: never;
    query?: never;
    url: '/api/tournament';
};

export type ApiTournamentPostErrors = {
    /**
     * The creation of the Arena tournament failed.
     */
    400: _Error;
};

export type ApiTournamentPostError = ApiTournamentPostErrors[keyof ApiTournamentPostErrors];

export type ApiTournamentPostResponses = {
    /**
     * The Arena tournament has been successfully created.
     */
    200: ArenaTournamentFull;
};

export type ApiTournamentPostResponse = ApiTournamentPostResponses[keyof ApiTournamentPostResponses];

export type TournamentData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: {
        /**
         * Specify which page of player standings to view.
         */
        page?: number;
    };
    url: '/api/tournament/{id}';
};

export type TournamentResponses = {
    /**
     * The information of the Arena tournament.
     */
    200: ArenaTournamentFull;
};

export type TournamentResponse = TournamentResponses[keyof TournamentResponses];

export type ApiTournamentUpdateData = {
    /**
     * Parameters of the tournament
     */
    body: {
        /**
         * The tournament name. Leave empty to get a random Grandmaster name
         */
        name?: string;
        /**
         * Clock initial time in minutes
         */
        clockTime: 0 | 0.25 | 0.5 | 0.75 | 1 | 1.5 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 10 | 15 | 20 | 25 | 30 | 40 | 50 | 60;
        /**
         * Clock increment in seconds
         */
        clockIncrement: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 10 | 15 | 20 | 25 | 30 | 40 | 50 | 60;
        /**
         * How long the tournament lasts, in minutes
         */
        minutes: 20 | 25 | 30 | 35 | 40 | 45 | 50 | 55 | 60 | 70 | 80 | 90 | 100 | 110 | 120 | 150 | 180 | 210 | 240 | 270 | 300 | 330 | 360 | 420 | 480 | 540 | 600 | 720;
        /**
         * How long to wait before starting the tournament, from now, in minutes
         */
        waitMinutes?: 1 | 2 | 3 | 5 | 10 | 15 | 20 | 30 | 45 | 60;
        /**
         * Timestamp (in milliseconds) to start the tournament at a given date and time. Overrides the `waitMinutes` setting
         */
        startDate?: number;
        variant?: VariantKey;
        /**
         * Games are rated and impact players ratings
         */
        rated?: boolean;
        position?: FromPositionFen;
        /**
         * Whether the players can use berserk. Only allowed if clockIncrement <= clockTime * 2
         */
        berserkable?: boolean;
        /**
         * After 2 wins, consecutive wins grant 4 points instead of 2.
         */
        streakable?: boolean;
        /**
         * Whether the players can discuss in a chat
         */
        hasChat?: boolean;
        /**
         * Anything you want to tell players about the tournament
         */
        description?: string;
        /**
         * Make the tournament private, and restrict access with a password
         */
        password?: string;
        /**
         * Minimum rating to join. Leave empty to let everyone join the tournament.
         */
        'conditions.minRating.rating'?: 1000 | 1100 | 1200 | 1300 | 1400 | 1500 | 1600 | 1700 | 1800 | 1900 | 2000 | 2100 | 2200 | 2300 | 2400 | 2500 | 2600;
        /**
         * Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
         */
        'conditions.maxRating.rating'?: 2200 | 2100 | 2000 | 1900 | 1800 | 1700 | 1600 | 1500 | 1400 | 1300 | 1200 | 1100 | 1000 | 900 | 800;
        /**
         * Minimum number of rated games required to join.
         */
        'conditions.nbRatedGame.nb'?: 0 | 5 | 10 | 15 | 20 | 30 | 40 | 50 | 75 | 100 | 150 | 200;
        /**
         * Predefined list of usernames that are allowed to join, separated by commas.
         * If this list is non-empty, then usernames absent from this list will be forbidden to join.
         * Adding `%titled` to the list additionally allows any titled player to join.
         * Example: `thibault,german11,%titled`
         *
         */
        'conditions.allowList'?: string;
        /**
         * Whether bots are allowed to join the tournament.
         */
        'conditions.bots'?: boolean;
        /**
         * Minium account age in days required to join.
         */
        'conditions.accountAge'?: 1 | 3 | 7 | 14 | 30 | 60 | 90 | 180 | 365 | 730 | 1095;
    };
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/tournament/{id}';
};

export type ApiTournamentUpdateErrors = {
    /**
     * The update of the Arena tournament failed.
     */
    400: _Error;
};

export type ApiTournamentUpdateError = ApiTournamentUpdateErrors[keyof ApiTournamentUpdateErrors];

export type ApiTournamentUpdateResponses = {
    /**
     * The Arena tournament was successfully updated.
     */
    200: ArenaTournamentFull;
};

export type ApiTournamentUpdateResponse = ApiTournamentUpdateResponses[keyof ApiTournamentUpdateResponses];

export type ApiTournamentJoinData = {
    /**
     * You may need these depending on the tournament to join
     */
    body?: {
        /**
         * The tournament password, if one is required.
         * Can also be a [user-specific entry code](https://github.com/lichess-org/api/tree/master/example/tournament-entry-code)
         * generated and shared by the organizer.
         *
         */
        password?: string;
        /**
         * The team to join the tournament with, for team battle tournaments
         */
        team?: string;
        /**
         * If the tournament is started, attempt to pair the user,
         * even if they are not connected to the tournament page.
         * This expires after one minute, to avoid pairing a user who is long gone.
         * You may call "join" again to extend the waiting.
         *
         */
        pairMeAsap?: boolean;
    };
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/tournament/{id}/join';
};

export type ApiTournamentJoinErrors = {
    /**
     * Joining the tournament failed.
     */
    400: _Error;
};

export type ApiTournamentJoinError = ApiTournamentJoinErrors[keyof ApiTournamentJoinErrors];

export type ApiTournamentJoinResponses = {
    /**
     * The tournament was successfully joined.
     */
    200: Ok;
};

export type ApiTournamentJoinResponse = ApiTournamentJoinResponses[keyof ApiTournamentJoinResponses];

export type ApiTournamentWithdrawData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/tournament/{id}/withdraw';
};

export type ApiTournamentWithdrawErrors = {
    /**
     * Pausing/leaving the tournament failed.
     */
    400: _Error;
};

export type ApiTournamentWithdrawError = ApiTournamentWithdrawErrors[keyof ApiTournamentWithdrawErrors];

export type ApiTournamentWithdrawResponses = {
    /**
     * The tournament was successfully paused or left.
     */
    200: Ok;
};

export type ApiTournamentWithdrawResponse = ApiTournamentWithdrawResponses[keyof ApiTournamentWithdrawResponses];

export type ApiTournamentTerminateData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/tournament/{id}/terminate';
};

export type ApiTournamentTerminateErrors = {
    /**
     * Terminating the tournament failed.
     */
    400: _Error;
};

export type ApiTournamentTerminateError = ApiTournamentTerminateErrors[keyof ApiTournamentTerminateErrors];

export type ApiTournamentTerminateResponses = {
    /**
     * The tournament was successfully terminated.
     */
    200: Ok;
};

export type ApiTournamentTerminateResponse = ApiTournamentTerminateResponses[keyof ApiTournamentTerminateResponses];

export type ApiTournamentTeamBattlePostData = {
    body: {
        /**
         * All team IDs of the team battle, separated by commas.
         * Make sure to always send the full list.
         * Teams that are not in the list will be removed from the team battle.
         * Example: `coders,zhigalko_sergei-fan-club,hhSwTKZv`
         *
         */
        teams: string;
        /**
         * Number team leaders per team.
         */
        nbLeaders: number;
    };
    path: {
        /**
         * The tournament ID
         */
        id: string;
    };
    query?: never;
    url: '/api/tournament/team-battle/{id}';
};

export type ApiTournamentTeamBattlePostErrors = {
    /**
     * The update of the team battle tournament failed.
     */
    400: _Error;
};

export type ApiTournamentTeamBattlePostError = ApiTournamentTeamBattlePostErrors[keyof ApiTournamentTeamBattlePostErrors];

export type ApiTournamentTeamBattlePostResponses = {
    /**
     * The team battle tournament was successfully updated.
     */
    200: ArenaTournamentFull;
};

export type ApiTournamentTeamBattlePostResponse = ApiTournamentTeamBattlePostResponses[keyof ApiTournamentTeamBattlePostResponses];

export type GamesByTournamentData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: {
        /**
         * Only games of a particular player. Leave empty to fetch games of all players.
         */
        player?: string;
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
    };
    url: '/api/tournament/{id}/games';
};

export type GamesByTournamentResponses = {
    /**
     * The list of games of an Arena tournament.
     */
    200: GamePgn;
};

export type GamesByTournamentResponse = GamesByTournamentResponses[keyof GamesByTournamentResponses];

export type ResultsByTournamentData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: {
        /**
         * Max number of players to fetch
         */
        nb?: number;
        /**
         * Add a `sheet` field to the player document.
         * It's an expensive server computation that slows down the stream.
         *
         */
        sheet?: boolean;
    };
    url: '/api/tournament/{id}/results';
};

export type ResultsByTournamentResponses = {
    /**
     * The results of the Arena tournament.
     */
    200: {
        rank: number;
        score: number;
        rating: number;
        username: string;
        performance: number;
        title?: Title;
        team: string;
        flair?: Flair;
        sheet?: ArenaSheet;
    };
};

export type ResultsByTournamentResponse = ResultsByTournamentResponses[keyof ResultsByTournamentResponses];

export type TeamsByTournamentData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/tournament/{id}/teams';
};

export type TeamsByTournamentResponses = {
    /**
     * The list of teams of a team battle tournament, with their respective top players.
     */
    200: {
        id: string;
        teams: Array<{
            rank: number;
            id: string;
            score: number;
            players: Array<{
                user: LightUser;
                score?: number;
            }>;
        }>;
    };
};

export type TeamsByTournamentResponse = TeamsByTournamentResponses[keyof TeamsByTournamentResponses];

export type ApiUserNameTournamentCreatedData = {
    body?: never;
    path: {
        /**
         * The user whose created tournaments to fetch
         */
        username: string;
    };
    query?: {
        /**
         * Max number of tournaments to fetch
         */
        nb?: number;
        /**
         * Include tournaments in the given status: "Created" (10), "Started" (20), "Finished" (30)
         * You can add this parameter more than once to include tournaments in different statuses.
         * Example: `?status=10&status=20`
         *
         */
        status?: 10 | 20 | 30;
    };
    url: '/api/user/{username}/tournament/created';
};

export type ApiUserNameTournamentCreatedResponses = {
    /**
     * The list of tournaments created by the user.
     */
    200: ArenaTournament;
};

export type ApiUserNameTournamentCreatedResponse = ApiUserNameTournamentCreatedResponses[keyof ApiUserNameTournamentCreatedResponses];

export type ApiUserNameTournamentPlayedData = {
    body?: never;
    path: {
        /**
         * The user whose played tournaments to fetch
         */
        username: string;
    };
    query?: {
        /**
         * Max number of tournaments to fetch
         */
        nb?: number;
        /**
         * Include the player performance rating in the response, at some cost for the server.
         *
         */
        performance?: boolean;
    };
    url: '/api/user/{username}/tournament/played';
};

export type ApiUserNameTournamentPlayedResponses = {
    /**
     * The list of tournaments played by the user.
     */
    200: ArenaTournamentPlayed;
};

export type ApiUserNameTournamentPlayedResponse = ApiUserNameTournamentPlayedResponses[keyof ApiUserNameTournamentPlayedResponses];

export type ApiSwissNewData = {
    /**
     * Parameters of the tournament
     */
    body: {
        /**
         * The tournament name. Leave empty to get a random Grandmaster name
         */
        name?: string;
        /**
         * Clock initial time in seconds
         */
        'clock.limit': 0 | 15 | 30 | 45 | 60 | 90 | 120 | 180 | 240 | 300 | 360 | 420 | 480 | 600 | 900 | 1200 | 1500 | 1800 | 2400 | 3000 | 3600 | 4200 | 4800 | 5400 | 6000 | 6600 | 7200 | 7800 | 8400 | 9000 | 9600 | 10200 | 10800;
        /**
         * Clock increment in seconds
         */
        'clock.increment': number;
        /**
         * Maximum number of rounds to play
         */
        nbRounds: number;
        /**
         * Timestamp in milliseconds to start the tournament at a given date and time. By default, it starts 10 minutes after creation.
         */
        startsAt?: number;
        /**
         * How long to wait between each round, in seconds.
         * Set to 99999999 to manually schedule each round from the tournament UI.
         * If empty or -1, a sensible value is picked automatically.
         *
         */
        roundInterval?: -1 | 5 | 10 | 20 | 30 | 45 | 60 | 120 | 180 | 300 | 600 | 900 | 1200 | 1800 | 2700 | 3600 | 86400 | 172800 | 604800 | 99999999;
        variant?: VariantKey;
        position?: SwissFromPositionFen;
        /**
         * Anything you want to tell players about the tournament
         */
        description?: string;
        /**
         * Games are rated and impact players ratings
         */
        rated?: boolean;
        /**
         * Make the tournament private and restrict access with a password.
         */
        password?: string;
        /**
         * Usernames of players that must not play together.
         * Two usernames per line, separated by a space.
         *
         */
        forbiddenPairings?: string;
        /**
         * Manual pairings for the next round.
         * Two usernames per line, separated by a space. Example:
         * ```
         * PlayerA PlayerB
         * PlayerC PlayerD
         * ```
         * To give a bye (1 point) to a player instead of a pairing, add a line like so:
         * ```
         * PlayerE 1
         * ```
         * Missing players will be considered absent and get zero points.
         *
         */
        manualPairings?: string;
        /**
         * Who can read and write in the chat.
         * - 0  = No-one
         * - 10 = Only team leaders
         * - 20 = Only team members
         * - 30 = All Lichess players
         *
         */
        chatFor?: number;
        /**
         * Minimum rating to join. Leave empty to let everyone join the tournament.
         */
        'conditions.minRating.rating'?: 1000 | 1100 | 1200 | 1300 | 1400 | 1500 | 1600 | 1700 | 1800 | 1900 | 2000 | 2100 | 2200 | 2300 | 2400 | 2500 | 2600;
        /**
         * Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
         */
        'conditions.maxRating.rating'?: 2200 | 2100 | 2000 | 1900 | 1800 | 1700 | 1600 | 1500 | 1400 | 1300 | 1200 | 1100 | 1000 | 900 | 800;
        /**
         * Minimum number of rated games required to join.
         */
        'conditions.nbRatedGame.nb'?: number;
        /**
         * Only let players join if they have played their last swiss game.
         * If they failed to show up in a recent swiss event, they won't be able to enter yours.
         * This results in a better swiss experience for the players who actually show up.
         *
         */
        'conditions.playYourGames'?: boolean;
        /**
         * Predefined list of usernames that are allowed to join, separated by commas.
         * If this list is non-empty, then usernames absent from this list will be forbidden to join.
         * Adding `%titled` to the list additionally allows any titled player to join.
         * Example: `thibault,german11,%titled`
         *
         */
        'conditions.allowList'?: string;
    };
    path: {
        /**
         * ID of the team
         */
        teamId: string;
    };
    query?: never;
    url: '/api/swiss/new/{teamId}';
};

export type ApiSwissNewErrors = {
    /**
     * The creation of the Swiss tournament failed.
     */
    400: _Error;
};

export type ApiSwissNewError = ApiSwissNewErrors[keyof ApiSwissNewErrors];

export type ApiSwissNewResponses = {
    /**
     * The Swiss tournament was successfully created.
     */
    200: SwissTournament;
};

export type ApiSwissNewResponse = ApiSwissNewResponses[keyof ApiSwissNewResponses];

export type SwissData = {
    body?: never;
    path: {
        /**
         * The Swiss tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/swiss/{id}';
};

export type SwissResponses = {
    /**
     * The information of the Swiss tournament.
     */
    200: SwissTournament;
};

export type SwissResponse = SwissResponses[keyof SwissResponses];

export type ApiSwissUpdateData = {
    /**
     * Parameters of the tournament
     */
    body: {
        /**
         * The tournament name. Leave empty to get a random Grandmaster name
         */
        name?: string;
        /**
         * Clock initial time in seconds
         */
        'clock.limit': 0 | 15 | 30 | 45 | 60 | 90 | 120 | 180 | 240 | 300 | 360 | 420 | 480 | 600 | 900 | 1200 | 1500 | 1800 | 2400 | 3000 | 3600 | 4200 | 4800 | 5400 | 6000 | 6600 | 7200 | 7800 | 8400 | 9000 | 9600 | 10200 | 10800;
        /**
         * Clock increment in seconds
         */
        'clock.increment': number;
        /**
         * Maximum number of rounds to play
         */
        nbRounds: number;
        /**
         * Timestamp in milliseconds to start the tournament at a given date and time. By default, it starts 10 minutes after creation.
         */
        startsAt?: number;
        /**
         * How long to wait between each round, in seconds.
         * Set to 99999999 to manually schedule each round from the tournament UI, or [with the API](#tag/Swiss-tournaments/operation/apiSwissScheduleNextRound).
         * If empty or -1, a sensible value is picked automatically.
         *
         */
        roundInterval?: -1 | 5 | 10 | 20 | 30 | 45 | 60 | 120 | 180 | 300 | 600 | 900 | 1200 | 1800 | 2700 | 3600 | 86400 | 172800 | 604800 | 99999999;
        variant?: VariantKey;
        position?: SwissFromPositionFen;
        /**
         * Anything you want to tell players about the tournament
         */
        description?: string;
        /**
         * Games are rated and impact players ratings
         */
        rated?: boolean;
        /**
         * Make the tournament private and restrict access with a password.
         */
        password?: string;
        /**
         * Usernames of players that must not play together.
         * Two usernames per line, separated by a space.
         *
         */
        forbiddenPairings?: string;
        /**
         * Manual pairings for the next round.
         * Two usernames per line, separated by a space.
         * Present players without a valid pairing will be given a bye, which is worth 1 point.
         * Forfeited players will get 0 points.
         *
         */
        manualPairings?: string;
        /**
         * Who can read and write in the chat.
         * - 0  = No-one
         * - 10 = Only team leaders
         * - 20 = Only team members
         * - 30 = All Lichess players
         *
         */
        chatFor?: number;
        /**
         * Minimum rating to join. Leave empty to let everyone join the tournament.
         */
        'conditions.minRating.rating'?: 1000 | 1100 | 1200 | 1300 | 1400 | 1500 | 1600 | 1700 | 1800 | 1900 | 2000 | 2100 | 2200 | 2300 | 2400 | 2500 | 2600;
        /**
         * Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
         */
        'conditions.maxRating.rating'?: 2200 | 2100 | 2000 | 1900 | 1800 | 1700 | 1600 | 1500 | 1400 | 1300 | 1200 | 1100 | 1000 | 900 | 800;
        /**
         * Minimum number of rated games required to join.
         */
        'conditions.nbRatedGame.nb'?: number;
        /**
         * Only let players join if they have played their last swiss game.
         * If they failed to show up in a recent swiss event, they won't be able to enter yours.
         * This results in a better swiss experience for the players who actually show up.
         *
         */
        'conditions.playYourGames'?: boolean;
        /**
         * Predefined list of usernames that are allowed to join, separated by commas.
         * If this list is non-empty, then usernames absent from this list will be forbidden to join.
         * Adding `%titled` to the list additionally allows any titled player to join.
         * Example: `thibault,german11,%titled`
         *
         */
        'conditions.allowList'?: string;
    };
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/swiss/{id}/edit';
};

export type ApiSwissUpdateErrors = {
    /**
     * Updating the swiss failed.
     */
    400: _Error;
    /**
     * This user cannot update this Swiss.
     */
    401: SwissUnauthorisedEdit;
};

export type ApiSwissUpdateError = ApiSwissUpdateErrors[keyof ApiSwissUpdateErrors];

export type ApiSwissUpdateResponses = {
    /**
     * The Swiss tournament was successfully updated.
     */
    200: SwissTournament;
};

export type ApiSwissUpdateResponse = ApiSwissUpdateResponses[keyof ApiSwissUpdateResponses];

export type ApiSwissScheduleNextRoundData = {
    /**
     * Parameters of the tournament
     */
    body: {
        /**
         * Timestamp in milliseconds to start the next round at a given date and time.
         */
        date?: number;
    };
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/swiss/{id}/schedule-next-round';
};

export type ApiSwissScheduleNextRoundErrors = {
    /**
     * Updating the swiss failed.
     */
    400: _Error;
    /**
     * This user cannot update this Swiss.
     */
    401: SwissUnauthorisedEdit;
};

export type ApiSwissScheduleNextRoundError = ApiSwissScheduleNextRoundErrors[keyof ApiSwissScheduleNextRoundErrors];

export type ApiSwissScheduleNextRoundResponses = {
    /**
     * The Swiss tournament was successfully updated.
     */
    204: void;
};

export type ApiSwissScheduleNextRoundResponse = ApiSwissScheduleNextRoundResponses[keyof ApiSwissScheduleNextRoundResponses];

export type ApiSwissJoinData = {
    /**
     * You may need these depending on the tournament to join
     */
    body?: {
        /**
         * The tournament password, if one is required
         */
        password?: string;
    };
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/swiss/{id}/join';
};

export type ApiSwissJoinErrors = {
    /**
     * Joining the tournament failed.
     */
    400: _Error;
};

export type ApiSwissJoinError = ApiSwissJoinErrors[keyof ApiSwissJoinErrors];

export type ApiSwissJoinResponses = {
    /**
     * The tournament was successfully joined.
     */
    200: Ok;
};

export type ApiSwissJoinResponse = ApiSwissJoinResponses[keyof ApiSwissJoinResponses];

export type ApiSwissWithdrawData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/swiss/{id}/withdraw';
};

export type ApiSwissWithdrawResponses = {
    /**
     * The tournament was successfully paused or left.
     */
    200: Ok;
};

export type ApiSwissWithdrawResponse = ApiSwissWithdrawResponses[keyof ApiSwissWithdrawResponses];

export type ApiSwissTerminateData = {
    body?: never;
    path: {
        /**
         * The Swiss tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/api/swiss/{id}/terminate';
};

export type ApiSwissTerminateErrors = {
    /**
     * Terminating the Swiss tournament failed.
     */
    400: _Error;
};

export type ApiSwissTerminateError = ApiSwissTerminateErrors[keyof ApiSwissTerminateErrors];

export type ApiSwissTerminateResponses = {
    /**
     * The Swiss tournament was successfully terminated.
     */
    200: Ok;
};

export type ApiSwissTerminateResponse = ApiSwissTerminateResponses[keyof ApiSwissTerminateResponses];

export type SwissTrfData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: never;
    url: '/swiss/{id}.trf';
};

export type SwissTrfResponses = {
    /**
     * The TRF representation of a Swiss tournament.
     */
    200: string;
};

export type SwissTrfResponse = SwissTrfResponses[keyof SwissTrfResponses];

export type GamesBySwissData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: {
        /**
         * Only the games played by a given player
         */
        player?: string;
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
    };
    url: '/api/swiss/{id}/games';
};

export type GamesBySwissResponses = {
    /**
     * The list of games of a Swiss tournament.
     */
    200: GamePgn;
};

export type GamesBySwissResponse = GamesBySwissResponses[keyof GamesBySwissResponses];

export type ResultsBySwissData = {
    body?: never;
    path: {
        /**
         * The tournament ID.
         */
        id: string;
    };
    query?: {
        /**
         * Max number of players to fetch
         */
        nb?: number;
    };
    url: '/api/swiss/{id}/results';
};

export type ResultsBySwissResponses = {
    /**
     * The results of a Swiss tournament.
     */
    200: {
        absent?: boolean;
        rank: number;
        points: number;
        tieBreak: number;
        rating: number;
        username: string;
        title?: Title;
        performance: number;
    };
};

export type ResultsBySwissResponse = ResultsBySwissResponses[keyof ResultsBySwissResponses];

export type ApiTeamSwissData = {
    body?: never;
    path: {
        teamId: string;
    };
    query?: {
        /**
         * How many tournaments to download.
         */
        max?: number;
        /**
         * [Filter] Only swiss tournaments in this current state.
         *
         */
        status?: SwissStatus & unknown;
        /**
         * [Filter] Only swiss tournaments created by a given user.
         *
         */
        createdBy?: string;
        /**
         * [Filter] Only swiss tournaments with a given name.
         *
         */
        name?: string;
    };
    url: '/api/team/{teamId}/swiss';
};

export type ApiTeamSwissResponses = {
    /**
     * The list of Swiss tournaments of a team.
     */
    200: SwissTournament;
};

export type ApiTeamSwissResponse = ApiTeamSwissResponses[keyof ApiTeamSwissResponses];

export type StudyChapterPgnData = {
    body?: never;
    path: {
        /**
         * The study ID
         */
        studyId: string;
        /**
         * The chapter ID
         */
        chapterId: string;
    };
    query?: {
        /**
         * Include clock comments in the PGN moves, when available.
         * Example: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *
         */
        clocks?: boolean;
        /**
         * Include analysis and annotator comments in the PGN moves, when available.
         * Example: `12. Bxf6 { [%eval 0.23] } a3 { White is in a pickle. }`
         *
         */
        comments?: boolean;
        /**
         * Include non-mainline moves, when available.
         * Example: `4. d4 Bb4+ (4... Nc6 5. Nf3 Bb4+ 6. Bd2 (6. Nbd2 O-O 7. O-O) 6... Bd6) 5. Nd2`
         *
         */
        variations?: boolean;
        /**
         * Add a `Source` PGN tag with the study chapter URL.
         * Example: `[Source "https://lichess.org/study/4NBHImfM/1Tk4IyTz"]`
         *
         */
        source?: boolean;
        /**
         * Add a `Orientation` PGN tag with the chapter predefined orientation.
         * Example: `[Orientation "white"]`
         *
         */
        orientation?: boolean;
    };
    url: '/api/study/{studyId}/{chapterId}.pgn';
};

export type StudyChapterPgnResponses = {
    /**
     * The chapter of the study.
     */
    200: StudyPgn;
};

export type StudyChapterPgnResponse = StudyChapterPgnResponses[keyof StudyChapterPgnResponses];

export type StudyAllChaptersPgnData = {
    body?: never;
    path: {
        /**
         * The study ID
         */
        studyId: string;
    };
    query?: {
        /**
         * Include clock comments in the PGN moves, when available.
         * Example: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *
         */
        clocks?: boolean;
        /**
         * Include analysis and annotator comments in the PGN moves, when available.
         * Example: `12. Bxf6 { [%eval 0.23] } a3 { White is in a pickle. }`
         *
         */
        comments?: boolean;
        /**
         * Include non-mainline moves, when available.
         * Example: `4. d4 Bb4+ (4... Nc6 5. Nf3 Bb4+ 6. Bd2 (6. Nbd2 O-O 7. O-O) 6... Bd6) 5. Nd2`
         *
         */
        variations?: boolean;
        /**
         * Add a `Source` PGN tag with the study chapter URL.
         * Example: `[Source "https://lichess.org/study/4NBHImfM/1Tk4IyTz"]`
         *
         */
        source?: boolean;
        /**
         * Add a `Orientation` PGN tag with the chapter predefined orientation.
         * Example: `[Orientation "white"]`
         *
         */
        orientation?: boolean;
    };
    url: '/api/study/{studyId}.pgn';
};

export type StudyAllChaptersPgnResponses = {
    /**
     * The PGN representation of the study.
     */
    200: StudyPgn;
};

export type StudyAllChaptersPgnResponse = StudyAllChaptersPgnResponses[keyof StudyAllChaptersPgnResponses];

export type StudyAllChaptersHeadData = {
    body?: never;
    path: {
        /**
         * The study ID
         */
        studyId: string;
    };
    query?: never;
    url: '/api/study/{studyId}.pgn';
};

export type StudyAllChaptersHeadResponses = {
    /**
     * The study headers.
     */
    204: void;
};

export type StudyAllChaptersHeadResponse = StudyAllChaptersHeadResponses[keyof StudyAllChaptersHeadResponses];

export type ApiStudyImportPgnData = {
    /**
     * Parameters of the import
     */
    body: {
        /**
         * PGN to import. Can contain multiple games separated by 2 or more newlines.
         *
         */
        pgn: string;
        /**
         * Name of the new chapter.
         * If not specified, or if multiple chapters are created, the names will be inferred from the PGN tags.
         *
         */
        name?: string;
        /**
         * Default board orientation.
         */
        orientation?: 'white' | 'black';
        variant?: VariantKey;
    };
    path: {
        /**
         * ID of the study
         */
        studyId: string;
    };
    query?: never;
    url: '/api/study/{studyId}/import-pgn';
};

export type ApiStudyImportPgnErrors = {
    /**
     * The creation of the chapter(s) failed.
     */
    400: _Error;
};

export type ApiStudyImportPgnError = ApiStudyImportPgnErrors[keyof ApiStudyImportPgnErrors];

export type ApiStudyImportPgnResponses = {
    /**
     * The chapters that were created.
     */
    200: StudyImportPgnChapters;
};

export type ApiStudyImportPgnResponse = ApiStudyImportPgnResponses[keyof ApiStudyImportPgnResponses];

export type StudyExportAllPgnData = {
    body?: never;
    path: {
        /**
         * The user whose studies we export
         */
        username: string;
    };
    query?: {
        /**
         * Include clock comments in the PGN moves, when available.
         * Example: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *
         */
        clocks?: boolean;
        /**
         * Include analysis and annotator comments in the PGN moves, when available.
         * Example: `12. Bxf6 { [%eval 0.23] } a3 { White is in a pickle. }`
         *
         */
        comments?: boolean;
        /**
         * Include non-mainline moves, when available.
         * Example: `4. d4 Bb4+ (4... Nc6 5. Nf3 Bb4+ 6. Bd2 (6. Nbd2 O-O 7. O-O) 6... Bd6) 5. Nd2`
         *
         */
        variations?: boolean;
        /**
         * Add a `Source` PGN tag with the study chapter URL.
         * Example: `[Source "https://lichess.org/study/4NBHImfM/1Tk4IyTz"]`
         *
         */
        source?: boolean;
        /**
         * Add a `Orientation` PGN tag with the chapter predefined orientation.
         * Example: `[Orientation "white"]`
         *
         */
        orientation?: boolean;
    };
    url: '/study/by/{username}/export.pgn';
};

export type StudyExportAllPgnResponses = {
    /**
     * The studies of the user.
     */
    200: StudyPgn;
};

export type StudyExportAllPgnResponse = StudyExportAllPgnResponses[keyof StudyExportAllPgnResponses];

export type StudyListMetadataData = {
    body?: never;
    path: {
        /**
         * The user whose studies we list
         */
        username: string;
    };
    query?: never;
    url: '/api/study/by/{username}';
};

export type StudyListMetadataResponses = {
    /**
     * The list of studies.
     */
    200: StudyMetadata;
};

export type StudyListMetadataResponse = StudyListMetadataResponses[keyof StudyListMetadataResponses];

export type ApiStudyStudyIdChapterIdDeleteData = {
    body?: never;
    path: {
        /**
         * The study ID
         */
        studyId: string;
        /**
         * The chapter ID
         */
        chapterId: string;
    };
    query?: never;
    url: '/api/study/{studyId}/{chapterId}';
};

export type ApiStudyStudyIdChapterIdDeleteResponses = {
    /**
     * Chapter successfully deleted
     */
    204: void;
};

export type ApiStudyStudyIdChapterIdDeleteResponse = ApiStudyStudyIdChapterIdDeleteResponses[keyof ApiStudyStudyIdChapterIdDeleteResponses];

export type BroadcastsOfficialData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Max number of broadcasts to fetch
         */
        nb?: number;
        /**
         * Convert the "description" field from markdown to HTML
         */
        html?: boolean;
    };
    url: '/api/broadcast';
};

export type BroadcastsOfficialResponses = {
    /**
     * The list of official broadcasts.
     */
    200: BroadcastWithRounds;
};

export type BroadcastsOfficialResponse = BroadcastsOfficialResponses[keyof BroadcastsOfficialResponses];

export type BroadcastsTopData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Which page to fetch. Only page 1 has "active" broadcasts.
         */
        page?: number;
        /**
         * Convert the "description" field from markdown to HTML
         */
        html?: boolean;
    };
    url: '/api/broadcast/top';
};

export type BroadcastsTopResponses = {
    /**
     * Paginated top broadcast previews.
     */
    200: BroadcastTop;
};

export type BroadcastsTopResponse = BroadcastsTopResponses[keyof BroadcastsTopResponses];

export type BroadcastsByUserData = {
    body?: never;
    path: {
        username: string;
    };
    query?: {
        page?: number;
        /**
         * Convert the "description" field from markdown to HTML
         */
        html?: boolean;
    };
    url: '/api/broadcast/by/{username}';
};

export type BroadcastsByUserResponses = {
    /**
     * A paginated list of the broadcasts created by a user.
     */
    200: {
        currentPage: number;
        maxPerPage: number;
        currentPageResults: Array<BroadcastByUser>;
        nbResults: number;
        previousPage: number | null;
        nextPage: number | null;
        nbPages: number;
    };
};

export type BroadcastsByUserResponse = BroadcastsByUserResponses[keyof BroadcastsByUserResponses];

export type BroadcastTourCreateData = {
    body: BroadcastForm;
    path?: never;
    query?: never;
    url: '/broadcast/new';
};

export type BroadcastTourCreateErrors = {
    /**
     * The creation of the broadcast tournament failed.
     */
    400: _Error;
};

export type BroadcastTourCreateError = BroadcastTourCreateErrors[keyof BroadcastTourCreateErrors];

export type BroadcastTourCreateResponses = {
    /**
     * The broadcast tournament was successfully created.
     */
    200: BroadcastWithRounds;
};

export type BroadcastTourCreateResponse = BroadcastTourCreateResponses[keyof BroadcastTourCreateResponses];

export type BroadcastTourGetData = {
    body?: never;
    path: {
        /**
         * The broadcast tournament ID
         */
        broadcastTournamentId: string;
    };
    query?: never;
    url: '/api/broadcast/{broadcastTournamentId}';
};

export type BroadcastTourGetResponses = {
    /**
     * The information about the broadcast tournament.
     */
    200: BroadcastWithRounds;
};

export type BroadcastTourGetResponse = BroadcastTourGetResponses[keyof BroadcastTourGetResponses];

export type BroadcastPlayersGetData = {
    body?: never;
    path: {
        /**
         * The broadcast tournament ID
         */
        broadcastTournamentId: string;
    };
    query?: never;
    url: '/broadcast/{broadcastTournamentId}/players';
};

export type BroadcastPlayersGetResponses = {
    /**
     * The broadcast players
     */
    200: Array<BroadcastPlayerEntry>;
};

export type BroadcastPlayersGetResponse = BroadcastPlayersGetResponses[keyof BroadcastPlayersGetResponses];

export type BroadcastTourUpdateData = {
    body: BroadcastForm;
    path: {
        /**
         * The broadcast ID
         */
        broadcastTournamentId: string;
    };
    query?: never;
    url: '/broadcast/{broadcastTournamentId}/edit';
};

export type BroadcastTourUpdateErrors = {
    /**
     * The broadcast tournament update failed.
     */
    400: _Error;
};

export type BroadcastTourUpdateError = BroadcastTourUpdateErrors[keyof BroadcastTourUpdateErrors];

export type BroadcastTourUpdateResponses = {
    /**
     * The broadcast tournament was successfully edited.
     */
    200: Ok;
};

export type BroadcastTourUpdateResponse = BroadcastTourUpdateResponses[keyof BroadcastTourUpdateResponses];

export type BroadcastRoundCreateData = {
    body: BroadcastRoundForm;
    path: {
        /**
         * The broadcast tournament ID
         */
        broadcastTournamentId: string;
    };
    query?: never;
    url: '/broadcast/{broadcastTournamentId}/new';
};

export type BroadcastRoundCreateErrors = {
    /**
     * The creation of the broadcast failed.
     */
    400: _Error;
};

export type BroadcastRoundCreateError = BroadcastRoundCreateErrors[keyof BroadcastRoundCreateErrors];

export type BroadcastRoundCreateResponses = {
    /**
     * The broadcast round was successfully created.
     */
    200: BroadcastRoundNew;
};

export type BroadcastRoundCreateResponse = BroadcastRoundCreateResponses[keyof BroadcastRoundCreateResponses];

export type BroadcastRoundGetData = {
    body?: never;
    path: {
        /**
         * The broadcast tournament slug. Only used for SEO, the slug can be safely replaced by `-`. Only the `broadcastRoundId` is actually used.
         */
        broadcastTournamentSlug: string;
        /**
         * The broadcast round slug. Only used for SEO, the slug can be safely replaced by `-`. Only the `broadcastRoundId` is actually used.
         */
        broadcastRoundSlug: string;
        /**
         * The broadcast Round ID
         */
        broadcastRoundId: string;
    };
    query?: never;
    url: '/api/broadcast/{broadcastTournamentSlug}/{broadcastRoundSlug}/{broadcastRoundId}';
};

export type BroadcastRoundGetResponses = {
    /**
     * The information about the broadcast round.
     */
    200: BroadcastRound;
};

export type BroadcastRoundGetResponse = BroadcastRoundGetResponses[keyof BroadcastRoundGetResponses];

export type BroadcastRoundUpdateData = {
    body: BroadcastRoundForm;
    path: {
        /**
         * The broadcast round ID
         */
        broadcastRoundId: string;
    };
    query?: never;
    url: '/broadcast/round/{broadcastRoundId}/edit';
};

export type BroadcastRoundUpdateErrors = {
    /**
     * The broadcast round update failed.
     */
    400: _Error;
};

export type BroadcastRoundUpdateError = BroadcastRoundUpdateErrors[keyof BroadcastRoundUpdateErrors];

export type BroadcastRoundUpdateResponses = {
    /**
     * The broadcast round was successfully edited.
     */
    200: Ok;
};

export type BroadcastRoundUpdateResponse = BroadcastRoundUpdateResponses[keyof BroadcastRoundUpdateResponses];

export type BroadcastRoundResetData = {
    body?: never;
    path: {
        /**
         * The broadcast round ID
         */
        broadcastRoundId: string;
    };
    query?: never;
    url: '/api/broadcast/round/{broadcastRoundId}/reset';
};

export type BroadcastRoundResetResponses = {
    /**
     * The broadcast round was successfully reset.
     */
    200: Ok;
};

export type BroadcastRoundResetResponse = BroadcastRoundResetResponses[keyof BroadcastRoundResetResponses];

export type BroadcastPushData = {
    /**
     * The PGN. It can contain up to 64 games, separated by a double new line.
     */
    body: string;
    path: {
        /**
         * The broadcast round ID
         */
        broadcastRoundId: string;
    };
    query?: never;
    url: '/api/broadcast/round/{broadcastRoundId}/push';
};

export type BroadcastPushErrors = {
    /**
     * There was a problem with the pushed PGN.
     */
    400: {
        error?: string;
    };
};

export type BroadcastPushError = BroadcastPushErrors[keyof BroadcastPushErrors];

export type BroadcastPushResponses = {
    /**
     * The broadcast was successfully updated.
     */
    200: BroadcastPgnPush;
};

export type BroadcastPushResponse = BroadcastPushResponses[keyof BroadcastPushResponses];

export type BroadcastStreamRoundPgnData = {
    body?: never;
    path: {
        /**
         * The broadcast round ID
         */
        broadcastRoundId: string;
    };
    query?: never;
    url: '/api/stream/broadcast/round/{broadcastRoundId}.pgn';
};

export type BroadcastStreamRoundPgnResponses = {
    /**
     * The PGN representation of the tournament games, then the PGNs of games as they are updated.
     */
    200: StudyPgn;
};

export type BroadcastStreamRoundPgnResponse = BroadcastStreamRoundPgnResponses[keyof BroadcastStreamRoundPgnResponses];

export type BroadcastRoundPgnData = {
    body?: never;
    path: {
        /**
         * The round ID
         */
        broadcastRoundId: string;
    };
    query?: never;
    url: '/api/broadcast/round/{broadcastRoundId}.pgn';
};

export type BroadcastRoundPgnResponses = {
    /**
     * The PGN representation of the round.
     */
    200: StudyPgn;
};

export type BroadcastRoundPgnResponse = BroadcastRoundPgnResponses[keyof BroadcastRoundPgnResponses];

export type BroadcastAllRoundsPgnData = {
    body?: never;
    path: {
        /**
         * The broadcast tournament ID
         */
        broadcastTournamentId: string;
    };
    query?: never;
    url: '/api/broadcast/{broadcastTournamentId}.pgn';
};

export type BroadcastAllRoundsPgnResponses = {
    /**
     * The PGN representation of the broadcast.
     */
    200: StudyPgn;
};

export type BroadcastAllRoundsPgnResponse = BroadcastAllRoundsPgnResponses[keyof BroadcastAllRoundsPgnResponses];

export type BroadcastMyRoundsGetData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * How many rounds to get
         */
        nb?: number;
    };
    url: '/api/broadcast/my-rounds';
};

export type BroadcastMyRoundsGetResponses = {
    /**
     * The broadcast rounds with their tournament and a `study.writeable` flag.
     */
    200: BroadcastMyRound;
};

export type BroadcastMyRoundsGetResponse = BroadcastMyRoundsGetResponses[keyof BroadcastMyRoundsGetResponses];

export type FidePlayerGetData = {
    body?: never;
    path: {
        /**
         * The FIDE player ID.
         */
        playerId: number;
    };
    query?: never;
    url: '/api/fide/player/{playerId}';
};

export type FidePlayerGetResponses = {
    /**
     * The information about the FIDE player.
     */
    200: FidePlayer;
};

export type FidePlayerGetResponse = FidePlayerGetResponses[keyof FidePlayerGetResponses];

export type FidePlayerSearchData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The search query.
         */
        q: string;
    };
    url: '/api/fide/player';
};

export type FidePlayerSearchResponses = {
    /**
     * The list of FIDE players.
     */
    200: Array<FidePlayer>;
};

export type FidePlayerSearchResponse = FidePlayerSearchResponses[keyof FidePlayerSearchResponses];

export type ApiSimulData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/simul';
};

export type ApiSimulResponses = {
    /**
     * The list of simuls.
     */
    200: {
        pending?: Array<Simul>;
        created?: Array<Simul>;
        started?: Array<Simul>;
        finished?: Array<Simul>;
    };
};

export type ApiSimulResponse = ApiSimulResponses[keyof ApiSimulResponses];

export type TeamShowData = {
    body?: never;
    path: {
        teamId: string;
    };
    query?: never;
    url: '/api/team/{teamId}';
};

export type TeamShowResponses = {
    /**
     * The information about the team.
     */
    200: Team;
};

export type TeamShowResponse = TeamShowResponses[keyof TeamShowResponses];

export type TeamAllData = {
    body?: never;
    path?: never;
    query?: {
        page?: number;
    };
    url: '/api/team/all';
};

export type TeamAllResponses = {
    /**
     * A paginated list of the most popular teams.
     */
    200: TeamPaginatorJson;
};

export type TeamAllResponse = TeamAllResponses[keyof TeamAllResponses];

export type TeamOfUsernameData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/team/of/{username}';
};

export type TeamOfUsernameResponses = {
    /**
     * The list of teams the user is a member of.
     */
    200: Array<Team>;
};

export type TeamOfUsernameResponse = TeamOfUsernameResponses[keyof TeamOfUsernameResponses];

export type TeamSearchData = {
    body?: never;
    path?: never;
    query?: {
        text?: string;
        page?: number;
    };
    url: '/api/team/search';
};

export type TeamSearchResponses = {
    /**
     * The paginated list of teams.
     */
    200: TeamPaginatorJson;
};

export type TeamSearchResponse = TeamSearchResponses[keyof TeamSearchResponses];

export type TeamIdUsersData = {
    body?: never;
    path: {
        teamId: string;
    };
    query?: {
        /**
         * Full user documents with performance ratings.
         * This limits the response to 1,000 users.
         *
         */
        full?: boolean;
    };
    url: '/api/team/{teamId}/users';
};

export type TeamIdUsersResponses = {
    /**
     * The list of users in the team.
     */
    200: {
        joinedTeamAt?: number;
        id: string;
        name: string;
        title?: Title;
        patron?: boolean;
    };
};

export type TeamIdUsersResponse = TeamIdUsersResponses[keyof TeamIdUsersResponses];

export type ApiTeamArenaData = {
    body?: never;
    path: {
        /**
         * ID of the team
         */
        teamId: string;
    };
    query?: {
        /**
         * How many tournaments to download.
         */
        max?: number;
        /**
         * [Filter] Only arena tournaments in this current state.
         *
         */
        status?: ArenaStatusName & unknown;
        /**
         * [Filter] Only arena tournaments created by a given user.
         *
         */
        createdBy?: string;
        /**
         * [Filter] Only arena tournaments with a given name.
         *
         */
        name?: string;
    };
    url: '/api/team/{teamId}/arena';
};

export type ApiTeamArenaResponses = {
    /**
     * The list of Arena tournaments of a team.
     */
    200: ArenaTournament;
};

export type ApiTeamArenaResponse = ApiTeamArenaResponses[keyof ApiTeamArenaResponses];

export type TeamIdJoinData = {
    body?: {
        /**
         * Required if team manually reviews admission requests.
         */
        message?: string;
        /**
         * Optional password, if the team requires one.
         */
        password?: string;
    };
    path: {
        teamId: string;
    };
    query?: never;
    url: '/team/{teamId}/join';
};

export type TeamIdJoinResponses = {
    /**
     * The request to join a team was successfully sent.
     */
    200: Ok;
};

export type TeamIdJoinResponse = TeamIdJoinResponses[keyof TeamIdJoinResponses];

export type TeamIdQuitData = {
    body?: never;
    path: {
        teamId: string;
    };
    query?: never;
    url: '/team/{teamId}/quit';
};

export type TeamIdQuitResponses = {
    /**
     * The logged in user has successfully left the team.
     */
    200: Ok;
};

export type TeamIdQuitResponse = TeamIdQuitResponses[keyof TeamIdQuitResponses];

export type TeamRequestsData = {
    body?: never;
    path: {
        teamId: string;
    };
    query?: {
        /**
         * Get the declined join requests
         */
        declined?: boolean;
    };
    url: '/api/team/{teamId}/requests';
};

export type TeamRequestsResponses = {
    /**
     * The list of pending join requests on your team
     */
    200: Array<TeamRequestWithUser>;
};

export type TeamRequestsResponse = TeamRequestsResponses[keyof TeamRequestsResponses];

export type TeamRequestAcceptData = {
    body?: never;
    path: {
        teamId: string;
        userId: string;
    };
    query?: never;
    url: '/api/team/{teamId}/request/{userId}/accept';
};

export type TeamRequestAcceptResponses = {
    /**
     * The member has been added to the team.
     */
    200: Ok;
};

export type TeamRequestAcceptResponse = TeamRequestAcceptResponses[keyof TeamRequestAcceptResponses];

export type TeamRequestDeclineData = {
    body?: never;
    path: {
        teamId: string;
        userId: string;
    };
    query?: never;
    url: '/api/team/{teamId}/request/{userId}/decline';
};

export type TeamRequestDeclineResponses = {
    /**
     * The join request has been declined and is no longer pending.
     */
    200: Ok;
};

export type TeamRequestDeclineResponse = TeamRequestDeclineResponses[keyof TeamRequestDeclineResponses];

export type TeamIdKickUserIdData = {
    body?: never;
    path: {
        teamId: string;
        userId: string;
    };
    query?: never;
    url: '/api/team/{teamId}/kick/{userId}';
};

export type TeamIdKickUserIdResponses = {
    /**
     * The member has been kicked from the team.
     */
    200: Ok;
};

export type TeamIdKickUserIdResponse = TeamIdKickUserIdResponses[keyof TeamIdKickUserIdResponses];

export type TeamIdPmAllData = {
    body: {
        /**
         * The message to send to all your team members.
         */
        message?: string;
    };
    path: {
        teamId: string;
    };
    query?: never;
    url: '/team/{teamId}/pm-all';
};

export type TeamIdPmAllErrors = {
    /**
     * The sending of message to all team members has failed.
     */
    400: _Error;
};

export type TeamIdPmAllError = TeamIdPmAllErrors[keyof TeamIdPmAllErrors];

export type TeamIdPmAllResponses = {
    /**
     * The message has successfully been sent to all team members.
     */
    200: Ok;
};

export type TeamIdPmAllResponse = TeamIdPmAllResponses[keyof TeamIdPmAllResponses];

export type StreamerLiveData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/streamer/live';
};

export type StreamerLiveResponses = {
    /**
     * The list of live streamers and their respective information.
     */
    200: Array<LightUser>;
};

export type StreamerLiveResponse = StreamerLiveResponses[keyof StreamerLiveResponses];

export type ApiCrosstableData = {
    body?: never;
    path: {
        user1: string;
        user2: string;
    };
    query?: {
        /**
         * Whether to get the current match data, if any
         */
        matchup?: boolean;
    };
    url: '/api/crosstable/{user1}/{user2}';
};

export type ApiCrosstableResponses = {
    /**
     * The crosstable of the two users.
     */
    200: Crosstable;
};

export type ApiCrosstableResponse = ApiCrosstableResponses[keyof ApiCrosstableResponses];

export type ApiPlayerAutocompleteData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The beginning of a username
         */
        term: string;
        /**
         * - `false` returns an array of usernames
         * - `true` returns an object with matching users
         *
         */
        object?: boolean;
        /**
         * Returns followed players matching `term` if any, else returns other players.
         * Requires [OAuth](#tag/OAuth).
         *
         */
        friend?: boolean;
    };
    url: '/api/player/autocomplete';
};

export type ApiPlayerAutocompleteResponses = {
    /**
     * An array of players which usernames start with the provided term.
     */
    200: Array<string> | {
        result?: Array<LightUserOnline>;
    };
};

export type ApiPlayerAutocompleteResponse = ApiPlayerAutocompleteResponses[keyof ApiPlayerAutocompleteResponses];

export type ReadNoteData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/user/{username}/note';
};

export type ReadNoteResponses = {
    /**
     * The list of notes you have added for this user
     */
    200: Array<UserNote>;
};

export type ReadNoteResponse = ReadNoteResponses[keyof ReadNoteResponses];

export type WriteNoteData = {
    body: {
        /**
         * The contents of the note
         */
        text: string;
    };
    path: {
        username: string;
    };
    query?: never;
    url: '/api/user/{username}/note';
};

export type WriteNoteResponses = {
    /**
     * The note was successfully added.
     */
    200: Ok;
};

export type WriteNoteResponse = WriteNoteResponses[keyof WriteNoteResponses];

export type ApiUserFollowingData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/rel/following';
};

export type ApiUserFollowingResponses = {
    /**
     * The list of users followed by a user.
     */
    200: UserExtended;
};

export type ApiUserFollowingResponse = ApiUserFollowingResponses[keyof ApiUserFollowingResponses];

export type FollowUserData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/rel/follow/{username}';
};

export type FollowUserResponses = {
    /**
     * The player was successfully added.
     */
    200: Ok;
};

export type FollowUserResponse = FollowUserResponses[keyof FollowUserResponses];

export type UnfollowUserData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/rel/unfollow/{username}';
};

export type UnfollowUserResponses = {
    /**
     * The player was successfully removed.
     */
    200: Ok;
};

export type UnfollowUserResponse = UnfollowUserResponses[keyof UnfollowUserResponses];

export type BlockUserData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/rel/block/{username}';
};

export type BlockUserResponses = {
    /**
     * The player was successfully added.
     */
    200: Ok;
};

export type BlockUserResponse = BlockUserResponses[keyof BlockUserResponses];

export type UnblockUserData = {
    body?: never;
    path: {
        username: string;
    };
    query?: never;
    url: '/api/rel/unblock/{username}';
};

export type UnblockUserResponses = {
    /**
     * The player was successfully removed.
     */
    200: Ok;
};

export type UnblockUserResponse = UnblockUserResponses[keyof UnblockUserResponses];

export type ApiStreamEventData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/stream/event';
};

export type ApiStreamEventResponses = {
    /**
     * The stream of events reaching the logged in user.
     */
    200: GameStartEvent | GameFinishEvent | ChallengeEvent | ChallengeCanceledEvent | ChallengeDeclinedEvent;
};

export type ApiStreamEventResponse = ApiStreamEventResponses[keyof ApiStreamEventResponses];

export type ApiBoardSeekData = {
    /**
     * Parameters of the seek
     */
    body?: {
        /**
         * Whether the game is rated and impacts players ratings.
         */
        rated?: boolean;
        variant?: VariantKey;
        /**
         * The rating range of potential opponents. Better left empty.
         * Example: 1500-1800
         *
         */
        ratingRange?: string;
    } & ({
        /**
         * Clock initial time in minutes. Required for real-time seeks.
         */
        time: number;
        /**
         * Clock increment in seconds. Required for real-time seeks.
         */
        increment: number;
        /**
         * The color to play. Better left empty to automatically get 50% white.
         */
        color?: 'random' | 'white' | 'black';
    } | {
        /**
         * Days per turn. Required for correspondence seeks.
         */
        days: 1 | 2 | 3 | 5 | 7 | 10 | 14;
    });
    path?: never;
    query?: never;
    url: '/api/board/seek';
};

export type ApiBoardSeekErrors = {
    /**
     * The creation of the seek failed.
     */
    400: _Error;
};

export type ApiBoardSeekError = ApiBoardSeekErrors[keyof ApiBoardSeekErrors];

export type ApiBoardSeekResponses = {
    /**
     * Only happens when doing a correspondence seek
     */
    200: {
        id: string;
    };
};

export type ApiBoardSeekResponse = ApiBoardSeekResponses[keyof ApiBoardSeekResponses];

export type BoardGameStreamData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/board/game/stream/{gameId}';
};

export type BoardGameStreamErrors = {
    /**
     * The game was not found.
     */
    404: NotFound;
};

export type BoardGameStreamError = BoardGameStreamErrors[keyof BoardGameStreamErrors];

export type BoardGameStreamResponses = {
    /**
     * The stream of the game.
     */
    200: GameFullEvent | GameStateEvent | ChatLineEvent | OpponentGone;
};

export type BoardGameStreamResponse = BoardGameStreamResponses[keyof BoardGameStreamResponses];

export type BoardGameMoveData = {
    body?: never;
    path: {
        gameId: string;
        /**
         * The move to play, in UCI format
         */
        move: string;
    };
    query?: {
        /**
         * Whether to offer (or agree to) a draw
         */
        offeringDraw?: boolean;
    };
    url: '/api/board/game/{gameId}/move/{move}';
};

export type BoardGameMoveErrors = {
    /**
     * The move failed.
     */
    400: _Error;
};

export type BoardGameMoveError = BoardGameMoveErrors[keyof BoardGameMoveErrors];

export type BoardGameMoveResponses = {
    /**
     * The move was successfully made.
     */
    200: Ok;
};

export type BoardGameMoveResponse = BoardGameMoveResponses[keyof BoardGameMoveResponses];

export type BoardGameChatGetData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/board/game/{gameId}/chat';
};

export type BoardGameChatGetResponses = {
    /**
     * The messages posted in the chat.
     */
    200: GameChat;
};

export type BoardGameChatGetResponse = BoardGameChatGetResponses[keyof BoardGameChatGetResponses];

export type BoardGameChatPostData = {
    body: {
        room: 'player' | 'spectator';
        text: string;
    };
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/board/game/{gameId}/chat';
};

export type BoardGameChatPostErrors = {
    /**
     * The posting of the message in the chat failed.
     */
    400: _Error;
};

export type BoardGameChatPostError = BoardGameChatPostErrors[keyof BoardGameChatPostErrors];

export type BoardGameChatPostResponses = {
    /**
     * The message was successfully posted in the chat.
     */
    200: Ok;
};

export type BoardGameChatPostResponse = BoardGameChatPostResponses[keyof BoardGameChatPostResponses];

export type BoardGameAbortData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/board/game/{gameId}/abort';
};

export type BoardGameAbortErrors = {
    /**
     * The abortion of the game failed.
     */
    400: _Error;
};

export type BoardGameAbortError = BoardGameAbortErrors[keyof BoardGameAbortErrors];

export type BoardGameAbortResponses = {
    /**
     * The game successfully aborted.
     */
    200: Ok;
};

export type BoardGameAbortResponse = BoardGameAbortResponses[keyof BoardGameAbortResponses];

export type BoardGameResignData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/board/game/{gameId}/resign';
};

export type BoardGameResignErrors = {
    /**
     * The resigning from the game failed.
     */
    400: _Error;
};

export type BoardGameResignError = BoardGameResignErrors[keyof BoardGameResignErrors];

export type BoardGameResignResponses = {
    /**
     * The game was successfully resigned.
     */
    200: Ok;
};

export type BoardGameResignResponse = BoardGameResignResponses[keyof BoardGameResignResponses];

export type BoardGameDrawData = {
    body?: never;
    path: {
        gameId: string;
        accept: boolean | 'yes';
    };
    query?: never;
    url: '/api/board/game/{gameId}/draw/{accept}';
};

export type BoardGameDrawErrors = {
    /**
     * The draw offering failed.
     */
    400: _Error;
};

export type BoardGameDrawError = BoardGameDrawErrors[keyof BoardGameDrawErrors];

export type BoardGameDrawResponses = {
    /**
     * The draw offer was successfully sent.
     */
    200: Ok;
};

export type BoardGameDrawResponse = BoardGameDrawResponses[keyof BoardGameDrawResponses];

export type BoardGameTakebackData = {
    body?: never;
    path: {
        gameId: string;
        accept: boolean | 'yes';
    };
    query?: never;
    url: '/api/board/game/{gameId}/takeback/{accept}';
};

export type BoardGameTakebackErrors = {
    /**
     * The takeback offering failed.
     */
    400: _Error;
};

export type BoardGameTakebackError = BoardGameTakebackErrors[keyof BoardGameTakebackErrors];

export type BoardGameTakebackResponses = {
    /**
     * The takeback offer was successfully sent.
     */
    200: Ok;
};

export type BoardGameTakebackResponse = BoardGameTakebackResponses[keyof BoardGameTakebackResponses];

export type BoardGameClaimVictoryData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/board/game/{gameId}/claim-victory';
};

export type BoardGameClaimVictoryErrors = {
    /**
     * The victory claim has failed.
     */
    400: _Error;
};

export type BoardGameClaimVictoryError = BoardGameClaimVictoryErrors[keyof BoardGameClaimVictoryErrors];

export type BoardGameClaimVictoryResponses = {
    /**
     * The victory was successfully claimed.
     */
    200: Ok;
};

export type BoardGameClaimVictoryResponse = BoardGameClaimVictoryResponses[keyof BoardGameClaimVictoryResponses];

export type BoardGameBerserkData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/board/game/{gameId}/berserk';
};

export type BoardGameBerserkErrors = {
    /**
     * The berserk has failed.
     */
    400: _Error;
};

export type BoardGameBerserkError = BoardGameBerserkErrors[keyof BoardGameBerserkErrors];

export type BoardGameBerserkResponses = {
    /**
     * The player successfully went berserk.
     */
    200: Ok;
};

export type BoardGameBerserkResponse = BoardGameBerserkResponses[keyof BoardGameBerserkResponses];

export type ApiBotOnlineData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * How many bot users to fetch
         */
        nb?: number;
    };
    url: '/api/bot/online';
};

export type ApiBotOnlineResponses = {
    /**
     * The list of online bot users
     */
    200: User;
};

export type ApiBotOnlineResponse = ApiBotOnlineResponses[keyof ApiBotOnlineResponses];

export type BotAccountUpgradeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/bot/account/upgrade';
};

export type BotAccountUpgradeErrors = {
    /**
     * The upgrade of the bot account failed.
     */
    400: _Error;
};

export type BotAccountUpgradeError = BotAccountUpgradeErrors[keyof BotAccountUpgradeErrors];

export type BotAccountUpgradeResponses = {
    /**
     * The bot account was successfully upgraded.
     */
    200: Ok;
};

export type BotAccountUpgradeResponse = BotAccountUpgradeResponses[keyof BotAccountUpgradeResponses];

export type BotGameStreamData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/bot/game/stream/{gameId}';
};

export type BotGameStreamErrors = {
    /**
     * The bot game was not found.
     */
    404: NotFound;
};

export type BotGameStreamError = BotGameStreamErrors[keyof BotGameStreamErrors];

export type BotGameStreamResponses = {
    /**
     * The stream of the bot game.
     */
    200: GameFullEvent | GameStateEvent | ChatLineEvent | OpponentGone;
};

export type BotGameStreamResponse = BotGameStreamResponses[keyof BotGameStreamResponses];

export type BotGameMoveData = {
    body?: never;
    path: {
        gameId: string;
        /**
         * The move to play, in UCI format
         */
        move: string;
    };
    query?: {
        /**
         * Whether to offer (or agree to) a draw
         */
        offeringDraw?: boolean;
    };
    url: '/api/bot/game/{gameId}/move/{move}';
};

export type BotGameMoveErrors = {
    /**
     * The bot move failed.
     */
    400: _Error;
};

export type BotGameMoveError = BotGameMoveErrors[keyof BotGameMoveErrors];

export type BotGameMoveResponses = {
    /**
     * The bot move was successfully made.
     */
    200: Ok;
};

export type BotGameMoveResponse = BotGameMoveResponses[keyof BotGameMoveResponses];

export type BotGameChatGetData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/bot/game/{gameId}/chat';
};

export type BotGameChatGetResponses = {
    /**
     * The messages posted in the chat.
     */
    200: GameChat;
};

export type BotGameChatGetResponse = BotGameChatGetResponses[keyof BotGameChatGetResponses];

export type BotGameChatData = {
    body: {
        room: 'player' | 'spectator';
        text: string;
    };
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/bot/game/{gameId}/chat';
};

export type BotGameChatErrors = {
    /**
     * The posting of the  message in chat failed.
     */
    400: _Error;
};

export type BotGameChatError = BotGameChatErrors[keyof BotGameChatErrors];

export type BotGameChatResponses = {
    /**
     * The message was successfully posted in chat.
     */
    200: Ok;
};

export type BotGameChatResponse = BotGameChatResponses[keyof BotGameChatResponses];

export type BotGameAbortData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/bot/game/{gameId}/abort';
};

export type BotGameAbortErrors = {
    /**
     * The abortion of the game failed.
     */
    400: _Error;
};

export type BotGameAbortError = BotGameAbortErrors[keyof BotGameAbortErrors];

export type BotGameAbortResponses = {
    /**
     * The game was successfully aborted.
     */
    200: Ok;
};

export type BotGameAbortResponse = BotGameAbortResponses[keyof BotGameAbortResponses];

export type BotGameResignData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/bot/game/{gameId}/resign';
};

export type BotGameResignErrors = {
    /**
     * Resigning the game failed.
     */
    400: _Error;
};

export type BotGameResignError = BotGameResignErrors[keyof BotGameResignErrors];

export type BotGameResignResponses = {
    /**
     * The game was successfully resigned from.
     */
    200: Ok;
};

export type BotGameResignResponse = BotGameResignResponses[keyof BotGameResignResponses];

export type BotGameDrawData = {
    body?: never;
    path: {
        gameId: string;
        accept: boolean | 'yes';
    };
    query?: never;
    url: '/api/bot/game/{gameId}/draw/{accept}';
};

export type BotGameDrawErrors = {
    /**
     * The draw offering failed.
     */
    400: _Error;
};

export type BotGameDrawError = BotGameDrawErrors[keyof BotGameDrawErrors];

export type BotGameDrawResponses = {
    /**
     * The draw offer was successfully sent.
     */
    200: Ok;
};

export type BotGameDrawResponse = BotGameDrawResponses[keyof BotGameDrawResponses];

export type BotGameTakebackData = {
    body?: never;
    path: {
        gameId: string;
        accept: boolean | 'yes';
    };
    query?: never;
    url: '/api/bot/game/{gameId}/takeback/{accept}';
};

export type BotGameTakebackErrors = {
    /**
     * The takeback offering failed.
     */
    400: _Error;
};

export type BotGameTakebackError = BotGameTakebackErrors[keyof BotGameTakebackErrors];

export type BotGameTakebackResponses = {
    /**
     * The takeback offer was successfully sent.
     */
    200: Ok;
};

export type BotGameTakebackResponse = BotGameTakebackResponses[keyof BotGameTakebackResponses];

export type BotGameClaimVictoryData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/api/bot/game/{gameId}/claim-victory';
};

export type BotGameClaimVictoryErrors = {
    /**
     * The victory claim has failed.
     */
    400: _Error;
};

export type BotGameClaimVictoryError = BotGameClaimVictoryErrors[keyof BotGameClaimVictoryErrors];

export type BotGameClaimVictoryResponses = {
    /**
     * The victory was successfully claimed.
     */
    200: Ok;
};

export type BotGameClaimVictoryResponse = BotGameClaimVictoryResponses[keyof BotGameClaimVictoryResponses];

export type ChallengeListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/challenge';
};

export type ChallengeListResponses = {
    /**
     * The list of challenges created by or targeted at the logged in user.
     */
    200: {
        /**
         * Incoming challenges i.e. targeted at you
         */
        in?: Array<ChallengeJson>;
        /**
         * Outgoing challenges i.e. created by you
         */
        out?: Array<ChallengeJson>;
    };
};

export type ChallengeListResponse = ChallengeListResponses[keyof ChallengeListResponses];

export type ChallengeCreateData = {
    /**
     * Parameters of the challenge
     */
    body?: {
        /**
         * Game is rated and impacts players ratings
         */
        rated?: boolean;
        /**
         * Clock initial time in seconds. If empty, a correspondence game is created. Valid values are 0, 15, 30, 45, 60, 90, and any multiple of 60 up to 10800 (3 hours).
         */
        'clock.limit'?: number;
        /**
         * Clock increment in seconds. If empty, a correspondence game is created.
         */
        'clock.increment'?: number;
        /**
         * Days per move, for correspondence games. Clock settings must be omitted.
         */
        days?: 1 | 2 | 3 | 5 | 7 | 10 | 14;
        /**
         * Which color you get to play
         */
        color?: 'random' | 'white' | 'black';
        variant?: VariantKey;
        fen?: FromPositionFen;
        /**
         * If set, the response is streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
         * The challenge is kept alive until the connection is closed by the client.
         * When the challenge is accepted, declined or canceled, a message of the form `{"done":"accepted"}` is sent,
         * then the connection is closed by the server.
         * If not set, the response is not streamed, and the challenge expires after 20s if not accepted.
         *
         */
        keepAliveStream?: boolean;
        /**
         * Extra game rules separated by commas.
         * Example: `noAbort,noRematch`
         *
         */
        rules?: 'noAbort' | 'noRematch' | 'noGiveTime' | 'noClaimWin' | 'noEarlyDraw';
    };
    path: {
        username: string;
    };
    query?: never;
    url: '/api/challenge/{username}';
};

export type ChallengeCreateErrors = {
    /**
     * The creation of the challenge failed.
     */
    400: _Error;
};

export type ChallengeCreateError = ChallengeCreateErrors[keyof ChallengeCreateErrors];

export type ChallengeCreateResponses = {
    /**
     * The challenge was successfully created.
     */
    200: ChallengeJson;
};

export type ChallengeCreateResponse = ChallengeCreateResponses[keyof ChallengeCreateResponses];

export type ChallengeShowData = {
    body?: never;
    path: {
        /**
         * The challenge ID
         */
        challengeId: string;
    };
    query?: never;
    url: '/api/challenge/{challengeId}/show';
};

export type ChallengeShowResponses = {
    /**
     * The challenge for that ID.
     */
    200: ChallengeJson;
};

export type ChallengeShowResponse = ChallengeShowResponses[keyof ChallengeShowResponses];

export type ChallengeAcceptData = {
    body?: never;
    path: {
        challengeId: string;
    };
    query?: never;
    url: '/api/challenge/{challengeId}/accept';
};

export type ChallengeAcceptErrors = {
    /**
     * The challenge to accept was not found.
     */
    404: NotFound;
};

export type ChallengeAcceptError = ChallengeAcceptErrors[keyof ChallengeAcceptErrors];

export type ChallengeAcceptResponses = {
    /**
     * The challenge was successfully accepted.
     */
    200: Ok;
};

export type ChallengeAcceptResponse = ChallengeAcceptResponses[keyof ChallengeAcceptResponses];

export type ChallengeDeclineData = {
    /**
     * Details related to decline of challenge
     */
    body?: {
        /**
         * Reason challenge was declined. It will be translated to the player's language. See [the full list in the translation file](https://github.com/ornicar/lila/blob/master/translation/source/challenge.xml#L14).
         */
        reason?: 'generic' | 'later' | 'tooFast' | 'tooSlow' | 'timeControl' | 'rated' | 'casual' | 'standard' | 'variant' | 'noBot' | 'onlyBot';
    };
    path: {
        challengeId: string;
    };
    query?: never;
    url: '/api/challenge/{challengeId}/decline';
};

export type ChallengeDeclineErrors = {
    /**
     * The challenge to decline was not found.
     */
    404: NotFound;
};

export type ChallengeDeclineError = ChallengeDeclineErrors[keyof ChallengeDeclineErrors];

export type ChallengeDeclineResponses = {
    /**
     * The challenge was successfully declined.
     */
    200: Ok;
};

export type ChallengeDeclineResponse = ChallengeDeclineResponses[keyof ChallengeDeclineResponses];

export type ChallengeCancelData = {
    body?: never;
    path: {
        challengeId: string;
    };
    query?: {
        /**
         * Optional `challenge:write` token of the opponent. If set, the game can be canceled even if both players have moved.
         */
        opponentToken?: string;
    };
    url: '/api/challenge/{challengeId}/cancel';
};

export type ChallengeCancelErrors = {
    /**
     * The challenge to cancel was not found.
     */
    404: NotFound;
};

export type ChallengeCancelError = ChallengeCancelErrors[keyof ChallengeCancelErrors];

export type ChallengeCancelResponses = {
    /**
     * The challenge was successfully cancelled.
     */
    200: Ok;
};

export type ChallengeCancelResponse = ChallengeCancelResponses[keyof ChallengeCancelResponses];

export type ChallengeAiData = {
    /**
     * Parameters of the game
     */
    body: {
        /**
         * AI strength
         */
        level?: number;
        /**
         * Clock initial time in seconds. If empty, a correspondence game is created.
         */
        'clock.limit'?: number;
        /**
         * Clock increment in seconds. If empty, a correspondence game is created.
         */
        'clock.increment'?: number;
        /**
         * Days per move, for correspondence games. Clock settings must be omitted.
         */
        days?: 1 | 2 | 3 | 5 | 7 | 10 | 14;
        /**
         * Which color you get to play
         */
        color?: 'random' | 'white' | 'black';
        variant?: VariantKey;
        fen?: FromPositionFen;
    };
    path?: never;
    query?: never;
    url: '/api/challenge/ai';
};

export type ChallengeAiErrors = {
    /**
     * The creation of a game with Lichess AI failed.
     */
    400: _Error;
};

export type ChallengeAiError = ChallengeAiErrors[keyof ChallengeAiErrors];

export type ChallengeAiResponses = {
    /**
     * The game with Lichess AI was successfully started.
     */
    201: GameJson;
};

export type ChallengeAiResponse = ChallengeAiResponses[keyof ChallengeAiResponses];

export type ChallengeOpenData = {
    /**
     * Parameters of the game
     */
    body?: {
        /**
         * Game is rated and impacts players ratings
         */
        rated?: boolean;
        /**
         * Clock initial time in seconds. If empty, a correspondence game is created.
         */
        'clock.limit'?: number;
        /**
         * Clock increment in seconds. If empty, a correspondence game is created.
         */
        'clock.increment'?: number;
        /**
         * Days per turn. For correspondence challenges.
         */
        days?: 1 | 2 | 3 | 5 | 7 | 10 | 14;
        variant?: VariantKey;
        fen?: FromPositionFen;
        /**
         * Optional name for the challenge, that players will see on the challenge page.
         */
        name?: string;
        /**
         * Extra game rules separated by commas.
         * Example: `noRematch,noGiveTime`
         * The `noAbort` rule is available for Lichess admins only
         *
         */
        rules?: 'noRematch' | 'noGiveTime' | 'noClaimWin' | 'noEarlyDraw' | 'noAbort';
        /**
         * Optional pair of usernames, separated by a comma.
         * If set, only these users will be allowed to join the game.
         * The first username gets the white pieces.
         * Example: `Username1,Username2`
         *
         */
        users?: string;
        /**
         * Timestamp in milliseconds to expire the challenge. Defaults to 24h after creation. Can't be more than 2 weeks after creation.
         */
        expiresAt?: number;
    };
    path?: never;
    query?: never;
    url: '/api/challenge/open';
};

export type ChallengeOpenErrors = {
    /**
     * The creation of the challenge failed.
     */
    400: _Error;
};

export type ChallengeOpenError = ChallengeOpenErrors[keyof ChallengeOpenErrors];

export type ChallengeOpenResponses = {
    /**
     * The challenge was successfully created.
     */
    200: ChallengeOpenJson;
};

export type ChallengeOpenResponse = ChallengeOpenResponses[keyof ChallengeOpenResponses];

export type ChallengeStartClocksData = {
    body?: never;
    path: {
        /**
         * ID of the game
         */
        gameId: string;
    };
    query: {
        /**
         * OAuth token of a player
         */
        token1: string;
        /**
         * OAuth token of the other player. Omit for AI games that have only one player.
         */
        token2?: string;
    };
    url: '/api/challenge/{gameId}/start-clocks';
};

export type ChallengeStartClocksResponses = {
    /**
     * The clock of a game was successfully started.
     */
    200: Ok;
};

export type ChallengeStartClocksResponse = ChallengeStartClocksResponses[keyof ChallengeStartClocksResponses];

export type BulkPairingListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/bulk-pairing';
};

export type BulkPairingListResponses = {
    /**
     * The list of bulk pairing the logged in user created.
     */
    200: Array<BulkPairing>;
};

export type BulkPairingListResponse = BulkPairingListResponses[keyof BulkPairingListResponses];

export type BulkPairingCreateData = {
    /**
     * Parameters of the pairings
     */
    body: {
        /**
         * OAuth tokens of all the players to pair, with the syntax `tokenOfWhitePlayerInGame1:tokenOfBlackPlayerInGame1,tokenOfWhitePlayerInGame2:tokenOfBlackPlayerInGame2,...`.
         * The 2 tokens of the players of a game are separated with `:`. The first token gets the white pieces. Games are separated with `,`.
         * Up to 1000 tokens can be sent, for a max of 500 games.
         * Each token must be included at most once.
         * Example: `token1:token2,token3:token4,token5:token6`
         *
         */
        players?: string;
        /**
         * Clock initial time in seconds. Example: `600`
         *
         */
        'clock.limit'?: number;
        /**
         * Clock increment in seconds. Example: `2`
         *
         */
        'clock.increment'?: number;
        /**
         * Days per turn. For correspondence games only.
         */
        days?: 1 | 2 | 3 | 5 | 7 | 10 | 14;
        /**
         * Date at which the games will be created as a Unix timestamp in milliseconds.
         * Up to 7 days in the future.
         * Omit, or set to current date and time, to start the games immediately.
         * Example: `1612289869919`
         *
         */
        pairAt?: number;
        /**
         * Date at which the clocks will be automatically started as a Unix timestamp in milliseconds.
         * Up to 7 days in the future.
         * Note that the clocks can start earlier than specified, if players start making moves in the game.
         * If omitted, the clocks will not start automatically.
         * Example: `1612289869919`
         *
         */
        startClocksAt?: number;
        /**
         * Game is rated and impacts players ratings
         */
        rated?: boolean;
        variant?: VariantKey;
        fen?: FromPositionFen;
        /**
         * Message that will be sent to each player, when the game is created.  It is sent from your user account.
         * `{opponent}` and `{game}` are placeholders that will be replaced with the opponent and the game URLs.
         * You can omit this field to send the default message,
         * but if you set your own message, it must at least contain the `{game}` placeholder.
         *
         */
        message?: string;
        /**
         * Extra game rules separated by commas.
         * Example: `noAbort,noRematch`
         *
         */
        rules?: 'noAbort' | 'noRematch' | 'noGiveTime' | 'noClaimWin' | 'noEarlyDraw';
    };
    path?: never;
    query?: never;
    url: '/api/bulk-pairing';
};

export type BulkPairingCreateErrors = {
    /**
     * The creation of the bulk pairings failed.
     */
    400: _Error;
};

export type BulkPairingCreateError = BulkPairingCreateErrors[keyof BulkPairingCreateErrors];

export type BulkPairingCreateResponses = {
    /**
     * The bulk pairing has been successfully created.
     */
    200: BulkPairing;
};

export type BulkPairingCreateResponse = BulkPairingCreateResponses[keyof BulkPairingCreateResponses];

export type BulkPairingStartClocksData = {
    body?: never;
    path: {
        /**
         * The ID of the bulk pairing
         */
        id: string;
    };
    query?: never;
    url: '/api/bulk-pairing/{id}/start-clocks';
};

export type BulkPairingStartClocksErrors = {
    /**
     * The bulk pairing was not found.
     */
    404: NotFound;
};

export type BulkPairingStartClocksError = BulkPairingStartClocksErrors[keyof BulkPairingStartClocksErrors];

export type BulkPairingStartClocksResponses = {
    /**
     * The clocks of the games of a bulk pairing were successfully started.
     */
    200: Ok;
};

export type BulkPairingStartClocksResponse = BulkPairingStartClocksResponses[keyof BulkPairingStartClocksResponses];

export type BulkPairingDeleteData = {
    body?: never;
    path: {
        /**
         * The ID of the bulk pairing
         */
        id: string;
    };
    query?: never;
    url: '/api/bulk-pairing/{id}';
};

export type BulkPairingDeleteErrors = {
    /**
     * The bulk pairing to delete was not found.
     */
    404: NotFound;
};

export type BulkPairingDeleteError = BulkPairingDeleteErrors[keyof BulkPairingDeleteErrors];

export type BulkPairingDeleteResponses = {
    /**
     * The bulk pairing was successfully deleted.
     */
    200: Ok;
};

export type BulkPairingDeleteResponse = BulkPairingDeleteResponses[keyof BulkPairingDeleteResponses];

export type BulkPairingGetData = {
    body?: never;
    path: {
        /**
         * The ID of the bulk pairing
         */
        id: string;
    };
    query?: never;
    url: '/api/bulk-pairing/{id}';
};

export type BulkPairingGetErrors = {
    /**
     * The bulk pairing was not found.
     */
    404: NotFound;
};

export type BulkPairingGetError = BulkPairingGetErrors[keyof BulkPairingGetErrors];

export type BulkPairingGetResponses = {
    /**
     * The bulk pairing.
     */
    200: BulkPairing;
};

export type BulkPairingGetResponse = BulkPairingGetResponses[keyof BulkPairingGetResponses];

export type BulkPairingIdGamesGetData = {
    body?: never;
    path: {
        /**
         * The ID of the bulk pairing
         */
        id: string;
    };
    query?: {
        /**
         * Include the PGN moves.
         */
        moves?: boolean;
        /**
         * Include the full PGN within the JSON response, in a `pgn` field.
         */
        pgnInJson?: boolean;
        /**
         * Include the PGN tags.
         */
        tags?: boolean;
        /**
         * Include clock status when available.
         * Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         * Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *
         */
        clocks?: boolean;
        /**
         * Include analysis evaluations and comments, when available.
         * Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         * Or in an `analysis` JSON field, depending on the response type.
         *
         */
        evals?: boolean;
        /**
         * Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *
         */
        accuracy?: boolean;
        /**
         * Include the opening name.
         * Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *
         */
        opening?: boolean;
        /**
         * Plies which mark the beginning of the middlegame and endgame.
         * Only available in JSON
         *
         */
        division?: boolean;
        /**
         * Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         * Example: `5... g4? { (-0.98 → 0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *
         */
        literate?: boolean;
    };
    url: '/api/bulk-pairing/{id}/games';
};

export type BulkPairingIdGamesGetResponses = {
    /**
     * The representation of the games.
     */
    200: GamePgn;
};

export type BulkPairingIdGamesGetResponse = BulkPairingIdGamesGetResponses[keyof BulkPairingIdGamesGetResponses];

export type RoundAddTimeData = {
    body?: never;
    path: {
        /**
         * ID of the game
         */
        gameId: string;
        /**
         * How many seconds to give
         */
        seconds: string;
    };
    query?: never;
    url: '/api/round/{gameId}/add-time/{seconds}';
};

export type RoundAddTimeResponses = {
    /**
     * Time was successfully added to the opponent's clock.
     */
    200: Ok;
};

export type RoundAddTimeResponse = RoundAddTimeResponses[keyof RoundAddTimeResponses];

export type AdminChallengeTokensData = {
    body: {
        /**
         * Usernames separated with commas
         */
        users: string;
        /**
         * User visible description of the token
         */
        description: string;
    };
    path?: never;
    query?: never;
    url: '/api/token/admin-challenge';
};

export type AdminChallengeTokensErrors = {
    /**
     * The creation of the tokens failed.
     */
    400: _Error;
};

export type AdminChallengeTokensError = AdminChallengeTokensErrors[keyof AdminChallengeTokensErrors];

export type AdminChallengeTokensResponses = {
    /**
     * The `challenge:write` tokens of each user
     */
    200: {
        [key: string]: string;
    };
};

export type AdminChallengeTokensResponse = AdminChallengeTokensResponses[keyof AdminChallengeTokensResponses];

export type InboxUsernameData = {
    body: {
        text: string;
    };
    path: {
        username: string;
    };
    query?: never;
    url: '/inbox/{username}';
};

export type InboxUsernameErrors = {
    /**
     * The sending of the private message has failed.
     */
    400: _Error;
};

export type InboxUsernameError = InboxUsernameErrors[keyof InboxUsernameErrors];

export type InboxUsernameResponses = {
    /**
     * The private message has been successfully sent.
     */
    200: Ok;
};

export type InboxUsernameResponse = InboxUsernameResponses[keyof InboxUsernameResponses];

export type ApiCloudEvalData = {
    body?: never;
    path?: never;
    query: {
        /**
         * FEN of the position
         */
        fen: string;
        /**
         * Number of variations
         */
        multiPv?: number;
        /**
         * Variant
         */
        variant?: VariantKey;
    };
    url: '/api/cloud-eval';
};

export type ApiCloudEvalErrors = {
    /**
     * The position was not found in the cloud evaluation database.
     */
    404: {
        error?: string;
    };
};

export type ApiCloudEvalError = ApiCloudEvalErrors[keyof ApiCloudEvalErrors];

export type ApiCloudEvalResponses = {
    /**
     * The evaluation of the position.
     */
    200: CloudEval;
};

export type ApiCloudEvalResponse = ApiCloudEvalResponses[keyof ApiCloudEvalResponses];

export type ApiExternalEngineListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/external-engine';
};

export type ApiExternalEngineListResponses = {
    /**
     * A list of external engines.
     */
    200: Array<ExternalEngine>;
};

export type ApiExternalEngineListResponse = ApiExternalEngineListResponses[keyof ApiExternalEngineListResponses];

export type ApiExternalEngineCreateData = {
    /**
     * A new external engine registration.
     */
    body: ExternalEngineRegistration;
    path?: never;
    query?: never;
    url: '/api/external-engine';
};

export type ApiExternalEngineCreateResponses = {
    /**
     * The registered engine.
     */
    200: ExternalEngine;
};

export type ApiExternalEngineCreateResponse = ApiExternalEngineCreateResponses[keyof ApiExternalEngineCreateResponses];

export type ApiExternalEngineDeleteData = {
    body?: never;
    path: {
        /**
         * The external engine id.
         */
        id: string;
    };
    query?: never;
    url: '/api/external-engine/{id}';
};

export type ApiExternalEngineDeleteResponses = {
    /**
     * Engine successfully deleted
     */
    200: Ok;
};

export type ApiExternalEngineDeleteResponse = ApiExternalEngineDeleteResponses[keyof ApiExternalEngineDeleteResponses];

export type ApiExternalEngineGetData = {
    body?: never;
    path: {
        /**
         * The external engine id.
         */
        id: string;
    };
    query?: never;
    url: '/api/external-engine/{id}';
};

export type ApiExternalEngineGetResponses = {
    /**
     * A registered engine.
     */
    200: ExternalEngine;
};

export type ApiExternalEngineGetResponse = ApiExternalEngineGetResponses[keyof ApiExternalEngineGetResponses];

export type ApiExternalEnginePutData = {
    /**
     * A modified engine registration.
     */
    body: ExternalEngineRegistration;
    path: {
        /**
         * The external engine id.
         */
        id: string;
    };
    query?: never;
    url: '/api/external-engine/{id}';
};

export type ApiExternalEnginePutResponses = {
    /**
     * A registered engine.
     */
    200: ExternalEngine;
};

export type ApiExternalEnginePutResponse = ApiExternalEnginePutResponses[keyof ApiExternalEnginePutResponses];

export type ApiExternalEngineAnalyseData = {
    /**
     * Engine credentials and analysis request.
     */
    body: {
        clientSecret: string;
        work: ExternalEngineWork;
    };
    path: {
        /**
         * The external engine id.
         */
        id: string;
    };
    query?: never;
    url: '/api/external-engine/{id}/analyse';
};

export type ApiExternalEngineAnalyseResponses = {
    /**
     * Stream of analysis output
     */
    200: {
        /**
         * Number of milliseconds the search has been going on
         */
        time: number;
        /**
         * Current search depth
         */
        depth: number;
        /**
         * Number of nodes visited so far
         */
        nodes: number;
        /**
         * Information about up to 5 pvs, with the primary pv at index 0.
         */
        pvs: Array<{
            /**
             * Current search depth of the pv
             */
            depth: number;
            /**
             * Evaluation in centi-pawns, from White's point of view
             */
            cp?: number;
            /**
             * Evaluation in signed moves to mate, from White's point of view
             */
            mate?: number;
            /**
             * Variation in UCI notation
             */
            moves: Array<string>;
        }>;
    };
};

export type ApiExternalEngineAnalyseResponse = ApiExternalEngineAnalyseResponses[keyof ApiExternalEngineAnalyseResponses];

export type ApiExternalEngineAcquireData = {
    /**
     * Provider credentials.
     */
    body: {
        providerSecret?: string;
    };
    path?: never;
    query?: never;
    url: '/api/external-engine/work';
};

export type ApiExternalEngineAcquireResponses = {
    /**
     * Analysis has been requested
     */
    200: {
        id: string;
        work: ExternalEngineWork;
        engine: ExternalEngine;
    };
    /**
     * No pending analysis
     */
    204: void;
};

export type ApiExternalEngineAcquireResponse = ApiExternalEngineAcquireResponses[keyof ApiExternalEngineAcquireResponses];

export type ApiExternalEngineSubmitData = {
    /**
     * Analysis results
     */
    body: string;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/external-engine/work/{id}';
};

export type ApiExternalEngineSubmitResponses = {
    /**
     * Thanks
     */
    200: unknown;
};

export type OauthData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Must be `code`.
         */
        response_type: string;
        /**
         * Arbitrary identifier that uniquely identifies your application.
         */
        client_id: string;
        /**
         * The absolute URL that the user should be redirected to with the authorization result.
         */
        redirect_uri: string;
        /**
         * Must be `S256`.
         */
        code_challenge_method: string;
        /**
         * Compute `BASE64URL(SHA256(code_verifier))`.
         */
        code_challenge: string;
        /**
         * Space separated list of requested OAuth scopes, if any.
         */
        scope?: string;
        /**
         * Hint that you want the user to log in with a specific Lichess username.
         */
        username?: string;
        /**
         * Arbitrary state that will be returned verbatim with the authorization result.
         */
        state?: string;
    };
    url: '/oauth';
};

export type OauthResponses = {
    /**
     * Authorization prompt will be displayed to the user.
     */
    200: unknown;
};

export type ApiTokenDeleteData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/token';
};

export type ApiTokenDeleteResponses = {
    /**
     * Access token revoked.
     */
    204: void;
};

export type ApiTokenDeleteResponse = ApiTokenDeleteResponses[keyof ApiTokenDeleteResponses];

export type ApiTokenData = {
    body: {
        /**
         * Must be `authorization_code`.
         */
        grant_type?: string;
        /**
         * The authorization code that was sent in the `code` parameter to your `redirect_uri`.
         */
        code?: string;
        /**
         * A `code_challenge` was used to request the authorization code. This must be the `code_verifier` it was derived from.
         */
        code_verifier?: string;
        /**
         * Must match the `redirect_uri` used to request the authorization code.
         */
        redirect_uri?: string;
        /**
         * Must match the `client_id` used to request the authorization code.
         */
        client_id?: string;
    };
    path?: never;
    query?: never;
    url: '/api/token';
};

export type ApiTokenErrors = {
    /**
     * Failed to obtain access token.
     */
    400: OAuthError;
};

export type ApiTokenError = ApiTokenErrors[keyof ApiTokenErrors];

export type ApiTokenResponses = {
    /**
     * Access token successfully obtained.
     */
    200: {
        token_type: string;
        access_token: string;
        expires_in: number;
    };
};

export type ApiTokenResponse = ApiTokenResponses[keyof ApiTokenResponses];

export type TokenTestData = {
    /**
     * OAuth tokens separated by commas. Up to 1000.
     */
    body: string;
    path?: never;
    query?: never;
    url: '/api/token/test';
};

export type TokenTestResponses = {
    /**
     * The representation of the OAuth tokens.
     */
    200: {
        [key: string]: {
            userId?: string;
            /**
             * Comma-separated list of scopes. Empty string if the token has no scopes.
             */
            scopes?: string;
            /**
             * Unix-timestampe in milliseconds or null if the token never expires.
             */
            expires?: number | null;
        } | null;
    };
};

export type TokenTestResponse = TokenTestResponses[keyof TokenTestResponses];

export type OpeningExplorerMasterData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * FEN of the root position
         */
        fen?: string;
        /**
         * Comma separated sequence of legal moves in UCI notation.
         * Play additional moves starting from `fen`.
         * Required to find an opening name, if `fen` is not an exact match
         * for a named position.
         *
         */
        play?: string;
        /**
         * Include only games from this year or later
         */
        since?: number;
        /**
         * Include only games from this year or earlier
         */
        until?: number;
        /**
         * Number of most common moves to display
         */
        moves?: number;
        /**
         * Number of top games to display
         */
        topGames?: number;
    };
    url: '/masters';
};

export type OpeningExplorerMasterResponses = {
    /**
     * Opening statistics and game references for the position.
     */
    200: OpeningExplorerMasters;
};

export type OpeningExplorerMasterResponse = OpeningExplorerMasterResponses[keyof OpeningExplorerMasterResponses];

export type OpeningExplorerLichessData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Variant
         */
        variant?: VariantKey;
        /**
         * FEN or EPD of the root position
         */
        fen?: string;
        /**
         * Comma separated sequence of legal moves in UCI notation.
         * Play additional moves starting from `fen`.
         * Required to find an opening name, if `fen` is not an exact match
         * for a named position.
         *
         */
        play?: string;
        /**
         * Comma separated list of game speeds to filter by
         */
        speeds?: Array<Speed>;
        /**
         * Comma separated list of ratings groups to filter by.
         * Each group ranges from its value to the next higher
         * group in the enum (`0` from 0 to 999, `1000` from 1000 to 1199,
         * ..., `2500` from 2500 to any rating above).
         *
         */
        ratings?: Array<0 | 1000 | 1200 | 1400 | 1600 | 1800 | 2000 | 2200 | 2500>;
        /**
         * Include only games from this month or later
         */
        since?: string;
        /**
         * Include only games from this month or earlier
         */
        until?: string;
        /**
         * Number of most common moves to display
         */
        moves?: number;
        /**
         * Number of top games to display
         */
        topGames?: number;
        /**
         * Number of recent games to display
         */
        recentGames?: number;
        /**
         * Optionally retrieve history
         */
        history?: boolean;
    };
    url: '/lichess';
};

export type OpeningExplorerLichessResponses = {
    /**
     * Opening statistics and game references for the position.
     */
    200: OpeningExplorerLichess;
};

export type OpeningExplorerLichessResponse = OpeningExplorerLichessResponses[keyof OpeningExplorerLichessResponses];

export type OpeningExplorerPlayerData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Username or ID of the player
         */
        player: string;
        /**
         * Look for games with *player* on the given side
         */
        color: 'white' | 'black';
        /**
         * Variant
         */
        variant?: VariantKey;
        /**
         * FEN of the root position
         */
        fen?: string;
        /**
         * Comma separated sequence of legal moves in UCI notation.
         * Play additional moves starting from `fen`.
         * Required to find an opening name, if `fen` is not an exact match
         * for a named position.
         *
         */
        play?: string;
        /**
         * Comma separated list of game speeds to look for
         */
        speeds?: Array<Speed>;
        /**
         * Comma separated list of modes
         */
        modes?: Array<'casual' | 'rated'>;
        /**
         * Include only games from this month or later
         */
        since?: string;
        /**
         * Include only games from this month or earlier
         */
        until?: string;
        /**
         * Number of most common moves to display
         */
        moves?: number;
        /**
         * Number of recent games to display
         */
        recentGames?: number;
    };
    url: '/player';
};

export type OpeningExplorerPlayerResponses = {
    /**
     * Opening statistics and game references for the position.
     */
    200: OpeningExplorerPlayer;
};

export type OpeningExplorerPlayerResponse = OpeningExplorerPlayerResponses[keyof OpeningExplorerPlayerResponses];

export type OpeningExplorerMasterGameData = {
    body?: never;
    path: {
        gameId: string;
    };
    query?: never;
    url: '/master/pgn/{gameId}';
};

export type OpeningExplorerMasterGameResponses = {
    /**
     * The PGN representation of the game.
     */
    200: MasterGamePgn;
};

export type OpeningExplorerMasterGameResponse = OpeningExplorerMasterGameResponses[keyof OpeningExplorerMasterGameResponses];

export type TablebaseStandardData = {
    body?: never;
    path?: never;
    query: {
        /**
         * FEN of the position. Underscores allowed.
         */
        fen: string;
    };
    url: '/standard';
};

export type TablebaseStandardResponses = {
    /**
     * The tablebase information for the position in standard chess.
     */
    200: TablebaseJson;
};

export type TablebaseStandardResponse = TablebaseStandardResponses[keyof TablebaseStandardResponses];

export type TablebaseAtomicData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/atomic';
};

export type TablebaseAtomicResponses = {
    /**
     * The tablebase information for the position in atomic chess.
     */
    200: string;
};

export type TablebaseAtomicResponse = TablebaseAtomicResponses[keyof TablebaseAtomicResponses];

export type AntichessAtomicData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/antichess';
};

export type AntichessAtomicResponses = {
    /**
     * The tablebase information for the position in antichess.
     */
    200: string;
};

export type AntichessAtomicResponse = AntichessAtomicResponses[keyof AntichessAtomicResponses];

export type ClientOptions = {
    baseUrl: 'https://lichess.org' | 'https://engine.lichess.ovh' | 'https://engine.lichess.ovh' | 'https://engine.lichess.ovh' | 'https://explorer.lichess.ovh' | 'https://explorer.lichess.ovh' | 'https://explorer.lichess.ovh' | 'https://explorer.lichess.ovh' | 'https://tablebase.lichess.ovh' | 'https://tablebase.lichess.ovh' | 'https://tablebase.lichess.ovh' | (string & {});
};